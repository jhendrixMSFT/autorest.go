//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azacr

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// ContainerRegistryClient contains the methods for the ContainerRegistry group.
// Don't use this type directly, use a constructor function instead.
type ContainerRegistryClient struct {
	internal   *azcore.Client
	endpoint   string
	apiVersion *string
}

// CheckDockerV2Support - Tells whether this Docker Registry instance supports Docker Registry HTTP API v2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientCheckDockerV2SupportOptions contains the optional parameters for the ContainerRegistryClient.CheckDockerV2Support
//     method.
func (client *ContainerRegistryClient) CheckDockerV2Support(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (result ContainerRegistryClientCheckDockerV2SupportResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.CheckDockerV2Support", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.checkDockerV2SupportCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// checkDockerV2SupportCreateRequest creates the CheckDockerV2Support request.
func (client *ContainerRegistryClient) checkDockerV2SupportCreateRequest(ctx context.Context, options *ContainerRegistryClientCheckDockerV2SupportOptions) (*policy.Request, error) {
	urlPath := "/v2/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// CreateManifest - Put the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - payload - Manifest body, can take v1 or v2 values depending on accept header
//   - options - ContainerRegistryClientCreateManifestOptions contains the optional parameters for the ContainerRegistryClient.CreateManifest
//     method.
func (client *ContainerRegistryClient) CreateManifest(ctx context.Context, name string, reference string, payload Manifest, options *ContainerRegistryClientCreateManifestOptions) (result ContainerRegistryClientCreateManifestResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.CreateManifest", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.createManifestCreateRequest(ctx, name, reference, payload, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.createManifestHandleResponse(resp)
	return
}

// createManifestCreateRequest creates the CreateManifest request.
func (client *ContainerRegistryClient) createManifestCreateRequest(ctx context.Context, name string, reference string, payload Manifest, options *ContainerRegistryClientCreateManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, payload)
}

// createManifestHandleResponse handles the CreateManifest response.
func (client *ContainerRegistryClient) createManifestHandleResponse(resp *http.Response) (result ContainerRegistryClientCreateManifestResponse, err error) {
	if val := resp.Header.Get("Docker-Content-Digest"); val != "" {
		result.DockerContentDigest = &val
	}
	if val := resp.Header.Get("Location"); val != "" {
		result.Location = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return ContainerRegistryClientCreateManifestResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	body, err := runtime.Payload(resp)
	if err != nil {
		return
	}
	result.RawJSON = body
	return result, nil
}

// DeleteManifest - Delete the manifest identified by name and reference. Note that a manifest can only be deleted by digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Digest of a BLOB
//   - options - ContainerRegistryClientDeleteManifestOptions contains the optional parameters for the ContainerRegistryClient.DeleteManifest
//     method.
func (client *ContainerRegistryClient) DeleteManifest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteManifestOptions) (result ContainerRegistryClientDeleteManifestResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.DeleteManifest", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteManifestCreateRequest(ctx, name, reference, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// deleteManifestCreateRequest creates the DeleteManifest request.
func (client *ContainerRegistryClient) deleteManifestCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteRepository - Delete the repository identified by name
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientDeleteRepositoryOptions contains the optional parameters for the ContainerRegistryClient.DeleteRepository
//     method.
func (client *ContainerRegistryClient) DeleteRepository(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (result ContainerRegistryClientDeleteRepositoryResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.DeleteRepository", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteRepositoryCreateRequest(ctx, name, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteRepositoryHandleResponse(resp)
	return
}

// deleteRepositoryCreateRequest creates the DeleteRepository request.
func (client *ContainerRegistryClient) deleteRepositoryCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientDeleteRepositoryOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteRepositoryHandleResponse handles the DeleteRepository response.
func (client *ContainerRegistryClient) deleteRepositoryHandleResponse(resp *http.Response) (result ContainerRegistryClientDeleteRepositoryResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeleteRepositoryResult); err != nil {
		result = ContainerRegistryClientDeleteRepositoryResponse{}
		return
	}
	return result, nil
}

// DeleteTag - Delete tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - options - ContainerRegistryClientDeleteTagOptions contains the optional parameters for the ContainerRegistryClient.DeleteTag
//     method.
func (client *ContainerRegistryClient) DeleteTag(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteTagOptions) (result ContainerRegistryClientDeleteTagResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.DeleteTag", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteTagCreateRequest(ctx, name, reference, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNotFound) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// deleteTagCreateRequest creates the DeleteTag request.
func (client *ContainerRegistryClient) deleteTagCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientDeleteTagOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetManifest - Get the manifest identified by name and reference where reference can be a tag or digest.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - A tag or a digest, pointing to a specific image
//   - options - ContainerRegistryClientGetManifestOptions contains the optional parameters for the ContainerRegistryClient.GetManifest
//     method.
func (client *ContainerRegistryClient) GetManifest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (result ContainerRegistryClientGetManifestResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.GetManifest", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getManifestCreateRequest(ctx, name, reference, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getManifestHandleResponse(resp)
	return
}

// getManifestCreateRequest creates the GetManifest request.
func (client *ContainerRegistryClient) getManifestCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetManifestOptions) (*policy.Request, error) {
	urlPath := "/v2/{name}/manifests/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	if options != nil && options.Accept != nil {
		req.Raw().Header["accept"] = []string{*options.Accept}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestHandleResponse handles the GetManifest response.
func (client *ContainerRegistryClient) getManifestHandleResponse(resp *http.Response) (result ContainerRegistryClientGetManifestResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ManifestWrapper); err != nil {
		result = ContainerRegistryClientGetManifestResponse{}
		return
	}
	return result, nil
}

// GetManifestProperties - Get manifest attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - options - ContainerRegistryClientGetManifestPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetManifestProperties
//     method.
func (client *ContainerRegistryClient) GetManifestProperties(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (result ContainerRegistryClientGetManifestPropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.GetManifestProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getManifestPropertiesCreateRequest(ctx, name, digest, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getManifestPropertiesHandleResponse(resp)
	return
}

// getManifestPropertiesCreateRequest creates the GetManifestProperties request.
func (client *ContainerRegistryClient) getManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, options *ContainerRegistryClientGetManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestPropertiesHandleResponse handles the GetManifestProperties response.
func (client *ContainerRegistryClient) getManifestPropertiesHandleResponse(resp *http.Response) (result ContainerRegistryClientGetManifestPropertiesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		result = ContainerRegistryClientGetManifestPropertiesResponse{}
		return
	}
	return result, nil
}

// NewGetManifestsPager - List manifests of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetManifestsOptions contains the optional parameters for the ContainerRegistryClient.NewGetManifestsPager
//     method.
func (client *ContainerRegistryClient) NewGetManifestsPager(name string, options *ContainerRegistryClientGetManifestsOptions) *runtime.Pager[ContainerRegistryClientGetManifestsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetManifestsResponse]{
		More: func(page ContainerRegistryClientGetManifestsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetManifestsResponse) (result ContainerRegistryClientGetManifestsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.NewGetManifestsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getManifestsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getManifestsHandleResponse(resp)
			return
		},
	})
}

// getManifestsCreateRequest creates the GetManifests request.
func (client *ContainerRegistryClient) getManifestsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetManifestsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if options != nil && options.Orderby != nil {
		reqQP.Set("orderby", *options.Orderby)
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getManifestsHandleResponse handles the GetManifests response.
func (client *ContainerRegistryClient) getManifestsHandleResponse(resp *http.Response) (result ContainerRegistryClientGetManifestsResponse, err error) {
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err = runtime.UnmarshalAsJSON(resp, &result.Manifests); err != nil {
		result = ContainerRegistryClientGetManifestsResponse{}
		return
	}
	return result, nil
}

// GetProperties - Get repository attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetProperties
//     method.
func (client *ContainerRegistryClient) GetProperties(ctx context.Context, name string, options *ContainerRegistryClientGetPropertiesOptions) (result ContainerRegistryClientGetPropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.GetProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getPropertiesCreateRequest(ctx, name, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getPropertiesHandleResponse(resp)
	return
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *ContainerRegistryClient) getPropertiesCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *ContainerRegistryClient) getPropertiesHandleResponse(resp *http.Response) (result ContainerRegistryClientGetPropertiesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		result = ContainerRegistryClientGetPropertiesResponse{}
		return
	}
	return result, nil
}

// NewGetRepositoriesPager - List repositories
//
// Generated from API version 2021-07-01
//   - options - ContainerRegistryClientGetRepositoriesOptions contains the optional parameters for the ContainerRegistryClient.NewGetRepositoriesPager
//     method.
func (client *ContainerRegistryClient) NewGetRepositoriesPager(options *ContainerRegistryClientGetRepositoriesOptions) *runtime.Pager[ContainerRegistryClientGetRepositoriesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetRepositoriesResponse]{
		More: func(page ContainerRegistryClientGetRepositoriesResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetRepositoriesResponse) (result ContainerRegistryClientGetRepositoriesResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.NewGetRepositoriesPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getRepositoriesCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getRepositoriesHandleResponse(resp)
			return
		},
	})
}

// getRepositoriesCreateRequest creates the GetRepositories request.
func (client *ContainerRegistryClient) getRepositoriesCreateRequest(ctx context.Context, options *ContainerRegistryClientGetRepositoriesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/_catalog"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRepositoriesHandleResponse handles the GetRepositories response.
func (client *ContainerRegistryClient) getRepositoriesHandleResponse(resp *http.Response) (result ContainerRegistryClientGetRepositoriesResponse, err error) {
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err = runtime.UnmarshalAsJSON(resp, &result.Repositories); err != nil {
		result = ContainerRegistryClientGetRepositoriesResponse{}
		return
	}
	return result, nil
}

// GetTagProperties - Get tag attributes by tag
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - options - ContainerRegistryClientGetTagPropertiesOptions contains the optional parameters for the ContainerRegistryClient.GetTagProperties
//     method.
func (client *ContainerRegistryClient) GetTagProperties(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetTagPropertiesOptions) (result ContainerRegistryClientGetTagPropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.GetTagProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getTagPropertiesCreateRequest(ctx, name, reference, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getTagPropertiesHandleResponse(resp)
	return
}

// getTagPropertiesCreateRequest creates the GetTagProperties request.
func (client *ContainerRegistryClient) getTagPropertiesCreateRequest(ctx context.Context, name string, reference string, options *ContainerRegistryClientGetTagPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTagPropertiesHandleResponse handles the GetTagProperties response.
func (client *ContainerRegistryClient) getTagPropertiesHandleResponse(resp *http.Response) (result ContainerRegistryClientGetTagPropertiesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		result = ContainerRegistryClientGetTagPropertiesResponse{}
		return
	}
	return result, nil
}

// NewGetTagsPager - List tags of a repository
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - options - ContainerRegistryClientGetTagsOptions contains the optional parameters for the ContainerRegistryClient.NewGetTagsPager
//     method.
func (client *ContainerRegistryClient) NewGetTagsPager(name string, options *ContainerRegistryClientGetTagsOptions) *runtime.Pager[ContainerRegistryClientGetTagsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ContainerRegistryClientGetTagsResponse]{
		More: func(page ContainerRegistryClientGetTagsResponse) bool {
			return page.Link != nil && len(*page.Link) > 0
		},
		Fetcher: func(ctx context.Context, page *ContainerRegistryClientGetTagsResponse) (result ContainerRegistryClientGetTagsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.NewGetTagsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getTagsCreateRequest(ctx, name, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.Link)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getTagsHandleResponse(resp)
			return
		},
	})
}

// getTagsCreateRequest creates the GetTags request.
func (client *ContainerRegistryClient) getTagsCreateRequest(ctx context.Context, name string, options *ContainerRegistryClientGetTagsOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Last != nil {
		reqQP.Set("last", *options.Last)
	}
	if options != nil && options.N != nil {
		reqQP.Set("n", strconv.FormatInt(int64(*options.N), 10))
	}
	if options != nil && options.Orderby != nil {
		reqQP.Set("orderby", *options.Orderby)
	}
	if options != nil && options.Digest != nil {
		reqQP.Set("digest", *options.Digest)
	}
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTagsHandleResponse handles the GetTags response.
func (client *ContainerRegistryClient) getTagsHandleResponse(resp *http.Response) (result ContainerRegistryClientGetTagsResponse, err error) {
	if val := resp.Header.Get("Link"); val != "" {
		result.Link = &val
	}
	if err = runtime.UnmarshalAsJSON(resp, &result.TagList); err != nil {
		result = ContainerRegistryClientGetTagsResponse{}
		return
	}
	return result, nil
}

// UpdateManifestProperties - Update properties of a manifest
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - digest - Digest of a BLOB
//   - value - Manifest attribute value
//   - options - ContainerRegistryClientUpdateManifestPropertiesOptions contains the optional parameters for the ContainerRegistryClient.UpdateManifestProperties
//     method.
func (client *ContainerRegistryClient) UpdateManifestProperties(ctx context.Context, name string, digest string, value ManifestWriteableProperties, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (result ContainerRegistryClientUpdateManifestPropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.UpdateManifestProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateManifestPropertiesCreateRequest(ctx, name, digest, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateManifestPropertiesHandleResponse(resp)
	return
}

// updateManifestPropertiesCreateRequest creates the UpdateManifestProperties request.
func (client *ContainerRegistryClient) updateManifestPropertiesCreateRequest(ctx context.Context, name string, digest string, value ManifestWriteableProperties, options *ContainerRegistryClientUpdateManifestPropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_manifests/{digest}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if digest == "" {
		return nil, errors.New("parameter digest cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{digest}", url.PathEscape(digest))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updateManifestPropertiesHandleResponse handles the UpdateManifestProperties response.
func (client *ContainerRegistryClient) updateManifestPropertiesHandleResponse(resp *http.Response) (result ContainerRegistryClientUpdateManifestPropertiesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ArtifactManifestProperties); err != nil {
		result = ContainerRegistryClientUpdateManifestPropertiesResponse{}
		return
	}
	return result, nil
}

// UpdateProperties - Update the attribute identified by name where reference is the name of the repository.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - value - Repository attribute value
//   - options - ContainerRegistryClientUpdatePropertiesOptions contains the optional parameters for the ContainerRegistryClient.UpdateProperties
//     method.
func (client *ContainerRegistryClient) UpdateProperties(ctx context.Context, name string, value RepositoryWriteableProperties, options *ContainerRegistryClientUpdatePropertiesOptions) (result ContainerRegistryClientUpdatePropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.UpdateProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updatePropertiesCreateRequest(ctx, name, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updatePropertiesHandleResponse(resp)
	return
}

// updatePropertiesCreateRequest creates the UpdateProperties request.
func (client *ContainerRegistryClient) updatePropertiesCreateRequest(ctx context.Context, name string, value RepositoryWriteableProperties, options *ContainerRegistryClientUpdatePropertiesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updatePropertiesHandleResponse handles the UpdateProperties response.
func (client *ContainerRegistryClient) updatePropertiesHandleResponse(resp *http.Response) (result ContainerRegistryClientUpdatePropertiesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ContainerRepositoryProperties); err != nil {
		result = ContainerRegistryClientUpdatePropertiesResponse{}
		return
	}
	return result, nil
}

// UpdateTagAttributes - Update tag attributes
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2021-07-01
//   - name - Name of the image (including the namespace)
//   - reference - Tag name
//   - value - Tag attribute value
//   - options - ContainerRegistryClientUpdateTagAttributesOptions contains the optional parameters for the ContainerRegistryClient.UpdateTagAttributes
//     method.
func (client *ContainerRegistryClient) UpdateTagAttributes(ctx context.Context, name string, reference string, value TagWriteableProperties, options *ContainerRegistryClientUpdateTagAttributesOptions) (result ContainerRegistryClientUpdateTagAttributesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "ContainerRegistryClient.UpdateTagAttributes", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateTagAttributesCreateRequest(ctx, name, reference, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateTagAttributesHandleResponse(resp)
	return
}

// updateTagAttributesCreateRequest creates the UpdateTagAttributes request.
func (client *ContainerRegistryClient) updateTagAttributesCreateRequest(ctx context.Context, name string, reference string, value TagWriteableProperties, options *ContainerRegistryClientUpdateTagAttributesOptions) (*policy.Request, error) {
	urlPath := "/acr/v1/{name}/_tags/{reference}"
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if reference == "" {
		return nil, errors.New("parameter reference cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{reference}", url.PathEscape(reference))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if client.apiVersion != nil {
		reqQP.Set("api-version", "2021-07-01")
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, value)
}

// updateTagAttributesHandleResponse handles the UpdateTagAttributes response.
func (client *ContainerRegistryClient) updateTagAttributesHandleResponse(resp *http.Response) (result ContainerRegistryClientUpdateTagAttributesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.ArtifactTagProperties); err != nil {
		result = ContainerRegistryClientUpdateTagAttributesResponse{}
		return
	}
	return result, nil
}
