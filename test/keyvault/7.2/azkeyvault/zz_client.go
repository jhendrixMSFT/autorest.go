//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package azkeyvault

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client contains the methods for the KeyVaultClient group.
// Don't use this type directly, use a constructor function instead.
type Client struct {
	internal *azcore.Client
}

// BackupCertificate - Requests that a backup of the specified certificate be downloaded to the client. All versions of the
// certificate will be downloaded. This operation requires the certificates/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - options - ClientBackupCertificateOptions contains the optional parameters for the Client.BackupCertificate method.
func (client *Client) BackupCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientBackupCertificateOptions) (result ClientBackupCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BackupCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.backupCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.backupCertificateHandleResponse(resp)
	return
}

// backupCertificateCreateRequest creates the BackupCertificate request.
func (client *Client) backupCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientBackupCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/backup"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupCertificateHandleResponse handles the BackupCertificate response.
func (client *Client) backupCertificateHandleResponse(resp *http.Response) (result ClientBackupCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.BackupCertificateResult); err != nil {
		result = ClientBackupCertificateResponse{}
		return
	}
	return result, nil
}

// BackupKey - The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this operation does
// NOT return key material in a form that can be used outside the Azure Key Vault system,
// the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault itself. The intent of this
// operation is to allow a client to GENERATE a key in one Azure Key Vault
// instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP operation may be used to
// export, in protected form, any key type from Azure Key Vault. Individual
// versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical boundaries only; meaning that
// a BACKUP from one geographical area cannot be restored to another
// geographical area. For example, a backup from the US geographical area cannot be restored in an EU geographical area. This
// operation requires the key/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - options - ClientBackupKeyOptions contains the optional parameters for the Client.BackupKey method.
func (client *Client) BackupKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientBackupKeyOptions) (result ClientBackupKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BackupKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.backupKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.backupKeyHandleResponse(resp)
	return
}

// backupKeyCreateRequest creates the BackupKey request.
func (client *Client) backupKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientBackupKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/backup"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupKeyHandleResponse handles the BackupKey response.
func (client *Client) backupKeyHandleResponse(resp *http.Response) (result ClientBackupKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.BackupKeyResult); err != nil {
		result = ClientBackupKeyResponse{}
		return
	}
	return result, nil
}

// BackupSecret - Requests that a backup of the specified secret be downloaded to the client. All versions of the secret will
// be downloaded. This operation requires the secrets/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - options - ClientBackupSecretOptions contains the optional parameters for the Client.BackupSecret method.
func (client *Client) BackupSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientBackupSecretOptions) (result ClientBackupSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BackupSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.backupSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.backupSecretHandleResponse(resp)
	return
}

// backupSecretCreateRequest creates the BackupSecret request.
func (client *Client) backupSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientBackupSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/backup"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupSecretHandleResponse handles the BackupSecret response.
func (client *Client) backupSecretHandleResponse(resp *http.Response) (result ClientBackupSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.BackupSecretResult); err != nil {
		result = ClientBackupSecretResponse{}
		return
	}
	return result, nil
}

// BackupStorageAccount - Requests that a backup of the specified storage account be downloaded to the client. This operation
// requires the storage/backup permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientBackupStorageAccountOptions contains the optional parameters for the Client.BackupStorageAccount method.
func (client *Client) BackupStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientBackupStorageAccountOptions) (result ClientBackupStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BackupStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.backupStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.backupStorageAccountHandleResponse(resp)
	return
}

// backupStorageAccountCreateRequest creates the BackupStorageAccount request.
func (client *Client) backupStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientBackupStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/backup"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// backupStorageAccountHandleResponse handles the BackupStorageAccount response.
func (client *Client) backupStorageAccountHandleResponse(resp *http.Response) (result ClientBackupStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.BackupStorageResult); err != nil {
		result = ClientBackupStorageAccountResponse{}
		return
	}
	return result, nil
}

// CreateCertificate - If this is the first version, the certificate resource is created. This operation requires the certificates/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - parameters - The parameters to create a certificate.
//   - options - ClientCreateCertificateOptions contains the optional parameters for the Client.CreateCertificate method.
func (client *Client) CreateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *ClientCreateCertificateOptions) (result ClientCreateCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.CreateCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.createCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.createCertificateHandleResponse(resp)
	return
}

// createCertificateCreateRequest creates the CreateCertificate request.
func (client *Client) createCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateCreateParameters, options *ClientCreateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/create"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createCertificateHandleResponse handles the CreateCertificate response.
func (client *Client) createCertificateHandleResponse(resp *http.Response) (result ClientCreateCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		result = ClientCreateCertificateResponse{}
		return
	}
	return result, nil
}

// CreateKey - The create key operation can be used to create any key type in Azure Key Vault. If the named key already exists,
// Azure Key Vault creates a new version of the key. It requires the keys/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name for the new key. The system will generate the version name for the new key.
//   - parameters - The parameters to create a key.
//   - options - ClientCreateKeyOptions contains the optional parameters for the Client.CreateKey method.
func (client *Client) CreateKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *ClientCreateKeyOptions) (result ClientCreateKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.CreateKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.createKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.createKeyHandleResponse(resp)
	return
}

// createKeyCreateRequest creates the CreateKey request.
func (client *Client) createKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyCreateParameters, options *ClientCreateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/create"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createKeyHandleResponse handles the CreateKey response.
func (client *Client) createKeyHandleResponse(resp *http.Response) (result ClientCreateKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientCreateKeyResponse{}
		return
	}
	return result, nil
}

// Decrypt - The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and specified
// algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of
// data may be decrypted, the size of this block is dependent on the target key and the algorithm to be used. The DECRYPT
// operation applies to asymmetric and symmetric keys stored in Azure Key Vault
// since it uses the private portion of the key. This operation requires the keys/decrypt permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the decryption operation.
//   - options - ClientDecryptOptions contains the optional parameters for the Client.Decrypt method.
func (client *Client) Decrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientDecryptOptions) (result ClientDecryptResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.Decrypt", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.decryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.decryptHandleResponse(resp)
	return
}

// decryptCreateRequest creates the Decrypt request.
func (client *Client) decryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientDecryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/decrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// decryptHandleResponse handles the Decrypt response.
func (client *Client) decryptHandleResponse(resp *http.Response) (result ClientDecryptResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		result = ClientDecryptResponse{}
		return
	}
	return result, nil
}

// DeleteCertificate - Deletes all versions of a certificate object along with its associated policy. Delete certificate cannot
// be used to remove individual versions of a certificate object. This operation requires the
// certificates/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - options - ClientDeleteCertificateOptions contains the optional parameters for the Client.DeleteCertificate method.
func (client *Client) DeleteCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOptions) (result ClientDeleteCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteCertificateHandleResponse(resp)
	return
}

// deleteCertificateCreateRequest creates the DeleteCertificate request.
func (client *Client) deleteCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateHandleResponse handles the DeleteCertificate response.
func (client *Client) deleteCertificateHandleResponse(resp *http.Response) (result ClientDeleteCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		result = ClientDeleteCertificateResponse{}
		return
	}
	return result, nil
}

// DeleteCertificateContacts - Deletes the certificate contacts for a specified key vault certificate. This operation requires
// the certificates/managecontacts permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientDeleteCertificateContactsOptions contains the optional parameters for the Client.DeleteCertificateContacts
//     method.
func (client *Client) DeleteCertificateContacts(ctx context.Context, vaultBaseURL string, options *ClientDeleteCertificateContactsOptions) (result ClientDeleteCertificateContactsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteCertificateContacts", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteCertificateContactsHandleResponse(resp)
	return
}

// deleteCertificateContactsCreateRequest creates the DeleteCertificateContacts request.
func (client *Client) deleteCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientDeleteCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateContactsHandleResponse handles the DeleteCertificateContacts response.
func (client *Client) deleteCertificateContactsHandleResponse(resp *http.Response) (result ClientDeleteCertificateContactsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		result = ClientDeleteCertificateContactsResponse{}
		return
	}
	return result, nil
}

// DeleteCertificateIssuer - The DeleteCertificateIssuer operation permanently removes the specified certificate issuer from
// the vault. This operation requires the certificates/manageissuers/deleteissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - issuerName - The name of the issuer.
//   - options - ClientDeleteCertificateIssuerOptions contains the optional parameters for the Client.DeleteCertificateIssuer
//     method.
func (client *Client) DeleteCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientDeleteCertificateIssuerOptions) (result ClientDeleteCertificateIssuerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteCertificateIssuer", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteCertificateIssuerHandleResponse(resp)
	return
}

// deleteCertificateIssuerCreateRequest creates the DeleteCertificateIssuer request.
func (client *Client) deleteCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientDeleteCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateIssuerHandleResponse handles the DeleteCertificateIssuer response.
func (client *Client) deleteCertificateIssuerHandleResponse(resp *http.Response) (result ClientDeleteCertificateIssuerResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		result = ClientDeleteCertificateIssuerResponse{}
		return
	}
	return result, nil
}

// DeleteCertificateOperation - Deletes the creation operation for a specified certificate that is in the process of being
// created. The certificate is no longer created. This operation requires the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - options - ClientDeleteCertificateOperationOptions contains the optional parameters for the Client.DeleteCertificateOperation
//     method.
func (client *Client) DeleteCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOperationOptions) (result ClientDeleteCertificateOperationResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteCertificateOperation", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteCertificateOperationHandleResponse(resp)
	return
}

// deleteCertificateOperationCreateRequest creates the DeleteCertificateOperation request.
func (client *Client) deleteCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientDeleteCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteCertificateOperationHandleResponse handles the DeleteCertificateOperation response.
func (client *Client) deleteCertificateOperationHandleResponse(resp *http.Response) (result ClientDeleteCertificateOperationResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		result = ClientDeleteCertificateOperationResponse{}
		return
	}
	return result, nil
}

// DeleteKey - The delete key operation cannot be used to remove individual versions of a key. This operation removes the
// cryptographic material associated with the key, which means the key is not usable for
// Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key to delete.
//   - options - ClientDeleteKeyOptions contains the optional parameters for the Client.DeleteKey method.
func (client *Client) DeleteKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientDeleteKeyOptions) (result ClientDeleteKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteKeyHandleResponse(resp)
	return
}

// deleteKeyCreateRequest creates the DeleteKey request.
func (client *Client) deleteKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientDeleteKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteKeyHandleResponse handles the DeleteKey response.
func (client *Client) deleteKeyHandleResponse(resp *http.Response) (result ClientDeleteKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		result = ClientDeleteKeyResponse{}
		return
	}
	return result, nil
}

// DeleteSasDefinition - Deletes a SAS definition from a specified storage account. This operation requires the storage/deletesas
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - options - ClientDeleteSasDefinitionOptions contains the optional parameters for the Client.DeleteSasDefinition method.
func (client *Client) DeleteSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientDeleteSasDefinitionOptions) (result ClientDeleteSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteSasDefinitionHandleResponse(resp)
	return
}

// deleteSasDefinitionCreateRequest creates the DeleteSasDefinition request.
func (client *Client) deleteSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientDeleteSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteSasDefinitionHandleResponse handles the DeleteSasDefinition response.
func (client *Client) deleteSasDefinitionHandleResponse(resp *http.Response) (result ClientDeleteSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionBundle); err != nil {
		result = ClientDeleteSasDefinitionResponse{}
		return
	}
	return result, nil
}

// DeleteSecret - The DELETE operation applies to any secret stored in Azure Key Vault. DELETE cannot be applied to an individual
// version of a secret. This operation requires the secrets/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - options - ClientDeleteSecretOptions contains the optional parameters for the Client.DeleteSecret method.
func (client *Client) DeleteSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientDeleteSecretOptions) (result ClientDeleteSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteSecretHandleResponse(resp)
	return
}

// deleteSecretCreateRequest creates the DeleteSecret request.
func (client *Client) deleteSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientDeleteSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteSecretHandleResponse handles the DeleteSecret response.
func (client *Client) deleteSecretHandleResponse(resp *http.Response) (result ClientDeleteSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		result = ClientDeleteSecretResponse{}
		return
	}
	return result, nil
}

// DeleteStorageAccount - Deletes a storage account. This operation requires the storage/delete permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientDeleteStorageAccountOptions contains the optional parameters for the Client.DeleteStorageAccount method.
func (client *Client) DeleteStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientDeleteStorageAccountOptions) (result ClientDeleteStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.DeleteStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.deleteStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.deleteStorageAccountHandleResponse(resp)
	return
}

// deleteStorageAccountCreateRequest creates the DeleteStorageAccount request.
func (client *Client) deleteStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientDeleteStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteStorageAccountHandleResponse handles the DeleteStorageAccount response.
func (client *Client) deleteStorageAccountHandleResponse(resp *http.Response) (result ClientDeleteStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedStorageBundle); err != nil {
		result = ClientDeleteStorageAccountResponse{}
		return
	}
	return result, nil
}

// Encrypt - The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored in Azure
// Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size
// of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT operation is only strictly
// necessary for symmetric keys stored in Azure Key Vault since protection with an
// asymmetric key can be performed using public portion of the key. This operation is supported for asymmetric keys as a convenience
// for callers that have a key-reference but do not have access to the
// public key material. This operation requires the keys/encrypt permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the encryption operation.
//   - options - ClientEncryptOptions contains the optional parameters for the Client.Encrypt method.
func (client *Client) Encrypt(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientEncryptOptions) (result ClientEncryptResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.Encrypt", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.encryptCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.encryptHandleResponse(resp)
	return
}

// encryptCreateRequest creates the Encrypt request.
func (client *Client) encryptCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientEncryptOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/encrypt"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// encryptHandleResponse handles the Encrypt response.
func (client *Client) encryptHandleResponse(resp *http.Response) (result ClientEncryptResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		result = ClientEncryptResponse{}
		return
	}
	return result, nil
}

// BeginFullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientBeginFullBackupOptions contains the optional parameters for the Client.BeginFullBackup method.
func (client *Client) BeginFullBackup(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (result *runtime.Poller[ClientFullBackupResponse], err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BeginFullBackup", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	if options == nil || options.ResumeToken == "" {
		var resp *http.Response
		resp, err = client.fullBackup(ctx, vaultBaseURL, options)
		if err != nil {
			return
		}
		result, err = runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientFullBackupResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		result, err = runtime.NewPollerFromResumeToken[ClientFullBackupResponse](options.ResumeToken, client.internal.Pipeline(), nil)
	}
	return
}

// FullBackup - Creates a full backup using a user-provided SAS token to an Azure blob storage container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
func (client *Client) fullBackup(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (resp *http.Response, err error) {
	req, err := client.fullBackupCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return
	}
	resp, err = client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// fullBackupCreateRequest creates the FullBackup request.
func (client *Client) fullBackupCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientBeginFullBackupOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.AzureStorageBlobContainerURI != nil {
		return req, runtime.MarshalAsJSON(req, *options.AzureStorageBlobContainerURI)
	}
	return req, nil
}

// FullBackupStatus - Returns the status of full backup operation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - jobID - The id returned as part of the backup request
//   - options - ClientFullBackupStatusOptions contains the optional parameters for the Client.FullBackupStatus method.
func (client *Client) FullBackupStatus(ctx context.Context, vaultBaseURL string, jobID string, options *ClientFullBackupStatusOptions) (result ClientFullBackupStatusResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.FullBackupStatus", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.fullBackupStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.fullBackupStatusHandleResponse(resp)
	return
}

// fullBackupStatusCreateRequest creates the FullBackupStatus request.
func (client *Client) fullBackupStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *ClientFullBackupStatusOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/backup/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// fullBackupStatusHandleResponse handles the FullBackupStatus response.
func (client *Client) fullBackupStatusHandleResponse(resp *http.Response) (result ClientFullBackupStatusResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.FullBackupOperation); err != nil {
		result = ClientFullBackupStatusResponse{}
		return
	}
	return result, nil
}

// BeginFullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage
// backup folder
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - restoreBlobDetails - The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
//   - options - ClientBeginFullRestoreOperationOptions contains the optional parameters for the Client.BeginFullRestoreOperation
//     method.
func (client *Client) BeginFullRestoreOperation(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (result *runtime.Poller[ClientFullRestoreOperationResponse], err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BeginFullRestoreOperation", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	if options == nil || options.ResumeToken == "" {
		var resp *http.Response
		resp, err = client.fullRestoreOperation(ctx, vaultBaseURL, restoreBlobDetails, options)
		if err != nil {
			return
		}
		result, err = runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientFullRestoreOperationResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		result, err = runtime.NewPollerFromResumeToken[ClientFullRestoreOperationResponse](options.ResumeToken, client.internal.Pipeline(), nil)
	}
	return
}

// FullRestoreOperation - Restores all key materials using the SAS token pointing to a previously stored Azure Blob storage
// backup folder
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
func (client *Client) fullRestoreOperation(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (resp *http.Response, err error) {
	req, err := client.fullRestoreOperationCreateRequest(ctx, vaultBaseURL, restoreBlobDetails, options)
	if err != nil {
		return
	}
	resp, err = client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// fullRestoreOperationCreateRequest creates the FullRestoreOperation request.
func (client *Client) fullRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, restoreBlobDetails RestoreOperationParameters, options *ClientBeginFullRestoreOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, restoreBlobDetails)
}

// GetCertificate - Gets information about a specific certificate. This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate in the given vault.
//   - certificateVersion - The version of the certificate. This URI fragment is optional. If not specified, the latest version
//     of the certificate is returned.
//   - options - ClientGetCertificateOptions contains the optional parameters for the Client.GetCertificate method.
func (client *Client) GetCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *ClientGetCertificateOptions) (result ClientGetCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getCertificateHandleResponse(resp)
	return
}

// getCertificateCreateRequest creates the GetCertificate request.
func (client *Client) getCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, options *ClientGetCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateHandleResponse handles the GetCertificate response.
func (client *Client) getCertificateHandleResponse(resp *http.Response) (result ClientGetCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientGetCertificateResponse{}
		return
	}
	return result, nil
}

// GetCertificateContacts - The GetCertificateContacts operation returns the set of certificate contact resources in the specified
// key vault. This operation requires the certificates/managecontacts permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetCertificateContactsOptions contains the optional parameters for the Client.GetCertificateContacts method.
func (client *Client) GetCertificateContacts(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateContactsOptions) (result ClientGetCertificateContactsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetCertificateContacts", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getCertificateContactsCreateRequest(ctx, vaultBaseURL, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getCertificateContactsHandleResponse(resp)
	return
}

// getCertificateContactsCreateRequest creates the GetCertificateContacts request.
func (client *Client) getCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateContactsHandleResponse handles the GetCertificateContacts response.
func (client *Client) getCertificateContactsHandleResponse(resp *http.Response) (result ClientGetCertificateContactsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		result = ClientGetCertificateContactsResponse{}
		return
	}
	return result, nil
}

// GetCertificateIssuer - The GetCertificateIssuer operation returns the specified certificate issuer resources in the specified
// key vault. This operation requires the certificates/manageissuers/getissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - issuerName - The name of the issuer.
//   - options - ClientGetCertificateIssuerOptions contains the optional parameters for the Client.GetCertificateIssuer method.
func (client *Client) GetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientGetCertificateIssuerOptions) (result ClientGetCertificateIssuerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetCertificateIssuer", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getCertificateIssuerHandleResponse(resp)
	return
}

// getCertificateIssuerCreateRequest creates the GetCertificateIssuer request.
func (client *Client) getCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, options *ClientGetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateIssuerHandleResponse handles the GetCertificateIssuer response.
func (client *Client) getCertificateIssuerHandleResponse(resp *http.Response) (result ClientGetCertificateIssuerResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		result = ClientGetCertificateIssuerResponse{}
		return
	}
	return result, nil
}

// NewGetCertificateIssuersPager - The GetCertificateIssuers operation returns the set of certificate issuer resources in
// the specified key vault. This operation requires the certificates/manageissuers/getissuers permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetCertificateIssuersOptions contains the optional parameters for the Client.NewGetCertificateIssuersPager
//     method.
func (client *Client) NewGetCertificateIssuersPager(vaultBaseURL string, options *ClientGetCertificateIssuersOptions) *runtime.Pager[ClientGetCertificateIssuersResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificateIssuersResponse]{
		More: func(page ClientGetCertificateIssuersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificateIssuersResponse) (result ClientGetCertificateIssuersResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetCertificateIssuersPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getCertificateIssuersCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getCertificateIssuersHandleResponse(resp)
			return
		},
	})
}

// getCertificateIssuersCreateRequest creates the GetCertificateIssuers request.
func (client *Client) getCertificateIssuersCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificateIssuersOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateIssuersHandleResponse handles the GetCertificateIssuers response.
func (client *Client) getCertificateIssuersHandleResponse(resp *http.Response) (result ClientGetCertificateIssuersResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateIssuerListResult); err != nil {
		result = ClientGetCertificateIssuersResponse{}
		return
	}
	return result, nil
}

// GetCertificateOperation - Gets the creation operation associated with a specified certificate. This operation requires
// the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - options - ClientGetCertificateOperationOptions contains the optional parameters for the Client.GetCertificateOperation
//     method.
func (client *Client) GetCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateOperationOptions) (result ClientGetCertificateOperationResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetCertificateOperation", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getCertificateOperationHandleResponse(resp)
	return
}

// getCertificateOperationCreateRequest creates the GetCertificateOperation request.
func (client *Client) getCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateOperationHandleResponse handles the GetCertificateOperation response.
func (client *Client) getCertificateOperationHandleResponse(resp *http.Response) (result ClientGetCertificateOperationResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		result = ClientGetCertificateOperationResponse{}
		return
	}
	return result, nil
}

// GetCertificatePolicy - The GetCertificatePolicy operation returns the specified certificate policy resources in the specified
// key vault. This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate in a given key vault.
//   - options - ClientGetCertificatePolicyOptions contains the optional parameters for the Client.GetCertificatePolicy method.
func (client *Client) GetCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificatePolicyOptions) (result ClientGetCertificatePolicyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetCertificatePolicy", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getCertificatePolicyHandleResponse(resp)
	return
}

// getCertificatePolicyCreateRequest creates the GetCertificatePolicy request.
func (client *Client) getCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificatePolicyHandleResponse handles the GetCertificatePolicy response.
func (client *Client) getCertificatePolicyHandleResponse(resp *http.Response) (result ClientGetCertificatePolicyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		result = ClientGetCertificatePolicyResponse{}
		return
	}
	return result, nil
}

// NewGetCertificateVersionsPager - The GetCertificateVersions operation returns the versions of a certificate in the specified
// key vault. This operation requires the certificates/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - options - ClientGetCertificateVersionsOptions contains the optional parameters for the Client.NewGetCertificateVersionsPager
//     method.
func (client *Client) NewGetCertificateVersionsPager(vaultBaseURL string, certificateName string, options *ClientGetCertificateVersionsOptions) *runtime.Pager[ClientGetCertificateVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificateVersionsResponse]{
		More: func(page ClientGetCertificateVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificateVersionsResponse) (result ClientGetCertificateVersionsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetCertificateVersionsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getCertificateVersionsCreateRequest(ctx, vaultBaseURL, certificateName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getCertificateVersionsHandleResponse(resp)
			return
		},
	})
}

// getCertificateVersionsCreateRequest creates the GetCertificateVersions request.
func (client *Client) getCertificateVersionsCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetCertificateVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/versions"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificateVersionsHandleResponse handles the GetCertificateVersions response.
func (client *Client) getCertificateVersionsHandleResponse(resp *http.Response) (result ClientGetCertificateVersionsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		result = ClientGetCertificateVersionsResponse{}
		return
	}
	return result, nil
}

// NewGetCertificatesPager - The GetCertificates operation returns the set of certificates resources in the specified key
// vault. This operation requires the certificates/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetCertificatesOptions contains the optional parameters for the Client.NewGetCertificatesPager method.
func (client *Client) NewGetCertificatesPager(vaultBaseURL string, options *ClientGetCertificatesOptions) *runtime.Pager[ClientGetCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetCertificatesResponse]{
		More: func(page ClientGetCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetCertificatesResponse) (result ClientGetCertificatesResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetCertificatesPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getCertificatesCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getCertificatesHandleResponse(resp)
			return
		},
	})
}

// getCertificatesCreateRequest creates the GetCertificates request.
func (client *Client) getCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getCertificatesHandleResponse handles the GetCertificates response.
func (client *Client) getCertificatesHandleResponse(resp *http.Response) (result ClientGetCertificatesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateListResult); err != nil {
		result = ClientGetCertificatesResponse{}
		return
	}
	return result, nil
}

// GetDeletedCertificate - The GetDeletedCertificate operation retrieves the deleted certificate information plus its attributes,
// such as retention interval, scheduled permanent deletion and the current deletion recovery level.
// This operation requires the certificates/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate
//   - options - ClientGetDeletedCertificateOptions contains the optional parameters for the Client.GetDeletedCertificate method.
func (client *Client) GetDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetDeletedCertificateOptions) (result ClientGetDeletedCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetDeletedCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDeletedCertificateHandleResponse(resp)
	return
}

// getDeletedCertificateCreateRequest creates the GetDeletedCertificate request.
func (client *Client) getDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientGetDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedCertificateHandleResponse handles the GetDeletedCertificate response.
func (client *Client) getDeletedCertificateHandleResponse(resp *http.Response) (result ClientGetDeletedCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateBundle); err != nil {
		result = ClientGetDeletedCertificateResponse{}
		return
	}
	return result, nil
}

// NewGetDeletedCertificatesPager - The GetDeletedCertificates operation retrieves the certificates in the current vault which
// are in a deleted state and ready for recovery or purging. This operation includes deletion-specific
// information. This operation requires the certificates/get/list permission. This operation can only be enabled on soft-delete
// enabled vaults.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetDeletedCertificatesOptions contains the optional parameters for the Client.NewGetDeletedCertificatesPager
//     method.
func (client *Client) NewGetDeletedCertificatesPager(vaultBaseURL string, options *ClientGetDeletedCertificatesOptions) *runtime.Pager[ClientGetDeletedCertificatesResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedCertificatesResponse]{
		More: func(page ClientGetDeletedCertificatesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedCertificatesResponse) (result ClientGetDeletedCertificatesResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetDeletedCertificatesPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getDeletedCertificatesCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getDeletedCertificatesHandleResponse(resp)
			return
		},
	})
}

// getDeletedCertificatesCreateRequest creates the GetDeletedCertificates request.
func (client *Client) getDeletedCertificatesCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedCertificatesOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.IncludePending != nil {
		reqQP.Set("includePending", strconv.FormatBool(*options.IncludePending))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedCertificatesHandleResponse handles the GetDeletedCertificates response.
func (client *Client) getDeletedCertificatesHandleResponse(resp *http.Response) (result ClientGetDeletedCertificatesResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedCertificateListResult); err != nil {
		result = ClientGetDeletedCertificatesResponse{}
		return
	}
	return result, nil
}

// GetDeletedKey - The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can be
// invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This
// operation requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - options - ClientGetDeletedKeyOptions contains the optional parameters for the Client.GetDeletedKey method.
func (client *Client) GetDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetDeletedKeyOptions) (result ClientGetDeletedKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetDeletedKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDeletedKeyHandleResponse(resp)
	return
}

// getDeletedKeyCreateRequest creates the GetDeletedKey request.
func (client *Client) getDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeyHandleResponse handles the GetDeletedKey response.
func (client *Client) getDeletedKeyHandleResponse(resp *http.Response) (result ClientGetDeletedKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedKeyBundle); err != nil {
		result = ClientGetDeletedKeyResponse{}
		return
	}
	return result, nil
}

// NewGetDeletedKeysPager - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public
// part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys
// operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on any vault, it will return
// an error if invoked on a non soft-delete enabled vault. This operation
// requires the keys/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetDeletedKeysOptions contains the optional parameters for the Client.NewGetDeletedKeysPager method.
func (client *Client) NewGetDeletedKeysPager(vaultBaseURL string, options *ClientGetDeletedKeysOptions) *runtime.Pager[ClientGetDeletedKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedKeysResponse]{
		More: func(page ClientGetDeletedKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedKeysResponse) (result ClientGetDeletedKeysResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetDeletedKeysPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getDeletedKeysCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getDeletedKeysHandleResponse(resp)
			return
		},
	})
}

// getDeletedKeysCreateRequest creates the GetDeletedKeys request.
func (client *Client) getDeletedKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedKeysHandleResponse handles the GetDeletedKeys response.
func (client *Client) getDeletedKeysHandleResponse(resp *http.Response) (result ClientGetDeletedKeysResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedKeyListResult); err != nil {
		result = ClientGetDeletedKeysResponse{}
		return
	}
	return result, nil
}

// GetDeletedSasDefinition - The Get Deleted SAS Definition operation returns the specified deleted SAS definition along with
// its attributes. This operation requires the storage/getsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - options - ClientGetDeletedSasDefinitionOptions contains the optional parameters for the Client.GetDeletedSasDefinition
//     method.
func (client *Client) GetDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetDeletedSasDefinitionOptions) (result ClientGetDeletedSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetDeletedSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDeletedSasDefinitionHandleResponse(resp)
	return
}

// getDeletedSasDefinitionCreateRequest creates the GetDeletedSasDefinition request.
func (client *Client) getDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetDeletedSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSasDefinitionHandleResponse handles the GetDeletedSasDefinition response.
func (client *Client) getDeletedSasDefinitionHandleResponse(resp *http.Response) (result ClientGetDeletedSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionBundle); err != nil {
		result = ClientGetDeletedSasDefinitionResponse{}
		return
	}
	return result, nil
}

// NewGetDeletedSasDefinitionsPager - The Get Deleted Sas Definitions operation returns the SAS definitions that have been
// deleted for a vault enabled for soft-delete. This operation requires the storage/listsas permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientGetDeletedSasDefinitionsOptions contains the optional parameters for the Client.NewGetDeletedSasDefinitionsPager
//     method.
func (client *Client) NewGetDeletedSasDefinitionsPager(vaultBaseURL string, storageAccountName string, options *ClientGetDeletedSasDefinitionsOptions) *runtime.Pager[ClientGetDeletedSasDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedSasDefinitionsResponse]{
		More: func(page ClientGetDeletedSasDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedSasDefinitionsResponse) (result ClientGetDeletedSasDefinitionsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetDeletedSasDefinitionsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getDeletedSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getDeletedSasDefinitionsHandleResponse(resp)
			return
		},
	})
}

// getDeletedSasDefinitionsCreateRequest creates the GetDeletedSasDefinitions request.
func (client *Client) getDeletedSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedSasDefinitionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSasDefinitionsHandleResponse handles the GetDeletedSasDefinitions response.
func (client *Client) getDeletedSasDefinitionsHandleResponse(resp *http.Response) (result ClientGetDeletedSasDefinitionsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSasDefinitionListResult); err != nil {
		result = ClientGetDeletedSasDefinitionsResponse{}
		return
	}
	return result, nil
}

// GetDeletedSecret - The Get Deleted Secret operation returns the specified deleted secret along with its attributes. This
// operation requires the secrets/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - options - ClientGetDeletedSecretOptions contains the optional parameters for the Client.GetDeletedSecret method.
func (client *Client) GetDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetDeletedSecretOptions) (result ClientGetDeletedSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetDeletedSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDeletedSecretHandleResponse(resp)
	return
}

// getDeletedSecretCreateRequest creates the GetDeletedSecret request.
func (client *Client) getDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretHandleResponse handles the GetDeletedSecret response.
func (client *Client) getDeletedSecretHandleResponse(resp *http.Response) (result ClientGetDeletedSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSecretBundle); err != nil {
		result = ClientGetDeletedSecretResponse{}
		return
	}
	return result, nil
}

// NewGetDeletedSecretsPager - The Get Deleted Secrets operation returns the secrets that have been deleted for a vault enabled
// for soft-delete. This operation requires the secrets/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetDeletedSecretsOptions contains the optional parameters for the Client.NewGetDeletedSecretsPager method.
func (client *Client) NewGetDeletedSecretsPager(vaultBaseURL string, options *ClientGetDeletedSecretsOptions) *runtime.Pager[ClientGetDeletedSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedSecretsResponse]{
		More: func(page ClientGetDeletedSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedSecretsResponse) (result ClientGetDeletedSecretsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetDeletedSecretsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getDeletedSecretsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getDeletedSecretsHandleResponse(resp)
			return
		},
	})
}

// getDeletedSecretsCreateRequest creates the GetDeletedSecrets request.
func (client *Client) getDeletedSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedSecretsHandleResponse handles the GetDeletedSecrets response.
func (client *Client) getDeletedSecretsHandleResponse(resp *http.Response) (result ClientGetDeletedSecretsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedSecretListResult); err != nil {
		result = ClientGetDeletedSecretsResponse{}
		return
	}
	return result, nil
}

// GetDeletedStorageAccount - The Get Deleted Storage Account operation returns the specified deleted storage account along
// with its attributes. This operation requires the storage/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientGetDeletedStorageAccountOptions contains the optional parameters for the Client.GetDeletedStorageAccount
//     method.
func (client *Client) GetDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedStorageAccountOptions) (result ClientGetDeletedStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetDeletedStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDeletedStorageAccountHandleResponse(resp)
	return
}

// getDeletedStorageAccountCreateRequest creates the GetDeletedStorageAccount request.
func (client *Client) getDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedStorageAccountHandleResponse handles the GetDeletedStorageAccount response.
func (client *Client) getDeletedStorageAccountHandleResponse(resp *http.Response) (result ClientGetDeletedStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedStorageBundle); err != nil {
		result = ClientGetDeletedStorageAccountResponse{}
		return
	}
	return result, nil
}

// NewGetDeletedStorageAccountsPager - The Get Deleted Storage Accounts operation returns the storage accounts that have been
// deleted for a vault enabled for soft-delete. This operation requires the storage/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetDeletedStorageAccountsOptions contains the optional parameters for the Client.NewGetDeletedStorageAccountsPager
//     method.
func (client *Client) NewGetDeletedStorageAccountsPager(vaultBaseURL string, options *ClientGetDeletedStorageAccountsOptions) *runtime.Pager[ClientGetDeletedStorageAccountsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetDeletedStorageAccountsResponse]{
		More: func(page ClientGetDeletedStorageAccountsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetDeletedStorageAccountsResponse) (result ClientGetDeletedStorageAccountsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetDeletedStorageAccountsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getDeletedStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getDeletedStorageAccountsHandleResponse(resp)
			return
		},
	})
}

// getDeletedStorageAccountsCreateRequest creates the GetDeletedStorageAccounts request.
func (client *Client) getDeletedStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetDeletedStorageAccountsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDeletedStorageAccountsHandleResponse handles the GetDeletedStorageAccounts response.
func (client *Client) getDeletedStorageAccountsHandleResponse(resp *http.Response) (result ClientGetDeletedStorageAccountsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DeletedStorageListResult); err != nil {
		result = ClientGetDeletedStorageAccountsResponse{}
		return
	}
	return result, nil
}

// GetKey - The get key operation is applicable to all key types. If the requested key is symmetric, then no key material
// is released in the response. This operation requires the keys/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key to get.
//   - keyVersion - Adding the version parameter retrieves a specific version of a key. This URI fragment is optional. If not
//     specified, the latest version of the key is returned.
//   - options - ClientGetKeyOptions contains the optional parameters for the Client.GetKey method.
func (client *Client) GetKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *ClientGetKeyOptions) (result ClientGetKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getKeyHandleResponse(resp)
	return
}

// getKeyCreateRequest creates the GetKey request.
func (client *Client) getKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, options *ClientGetKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyHandleResponse handles the GetKey response.
func (client *Client) getKeyHandleResponse(resp *http.Response) (result ClientGetKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientGetKeyResponse{}
		return
	}
	return result, nil
}

// NewGetKeyVersionsPager - The full key identifier, attributes, and tags are provided in the response. This operation requires
// the keys/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - options - ClientGetKeyVersionsOptions contains the optional parameters for the Client.NewGetKeyVersionsPager method.
func (client *Client) NewGetKeyVersionsPager(vaultBaseURL string, keyName string, options *ClientGetKeyVersionsOptions) *runtime.Pager[ClientGetKeyVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetKeyVersionsResponse]{
		More: func(page ClientGetKeyVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetKeyVersionsResponse) (result ClientGetKeyVersionsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetKeyVersionsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getKeyVersionsCreateRequest(ctx, vaultBaseURL, keyName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getKeyVersionsHandleResponse(resp)
			return
		},
	})
}

// getKeyVersionsCreateRequest creates the GetKeyVersions request.
func (client *Client) getKeyVersionsCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientGetKeyVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/versions"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeyVersionsHandleResponse handles the GetKeyVersions response.
func (client *Client) getKeyVersionsHandleResponse(resp *http.Response) (result ClientGetKeyVersionsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		result = ClientGetKeyVersionsResponse{}
		return
	}
	return result, nil
}

// NewGetKeysPager - Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public part
// of a stored key. The LIST operation is applicable to all key types, however only the base key
// identifier, attributes, and tags are provided in the response. Individual versions of a key are not listed in the response.
// This operation requires the keys/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetKeysOptions contains the optional parameters for the Client.NewGetKeysPager method.
func (client *Client) NewGetKeysPager(vaultBaseURL string, options *ClientGetKeysOptions) *runtime.Pager[ClientGetKeysResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetKeysResponse]{
		More: func(page ClientGetKeysResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetKeysResponse) (result ClientGetKeysResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetKeysPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getKeysCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getKeysHandleResponse(resp)
			return
		},
	})
}

// getKeysCreateRequest creates the GetKeys request.
func (client *Client) getKeysCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetKeysOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getKeysHandleResponse handles the GetKeys response.
func (client *Client) getKeysHandleResponse(resp *http.Response) (result ClientGetKeysResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyListResult); err != nil {
		result = ClientGetKeysResponse{}
		return
	}
	return result, nil
}

// GetSasDefinition - Gets information about a SAS definition for the specified storage account. This operation requires the
// storage/getsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - options - ClientGetSasDefinitionOptions contains the optional parameters for the Client.GetSasDefinition method.
func (client *Client) GetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetSasDefinitionOptions) (result ClientGetSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getSasDefinitionHandleResponse(resp)
	return
}

// getSasDefinitionCreateRequest creates the GetSasDefinition request.
func (client *Client) getSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientGetSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSasDefinitionHandleResponse handles the GetSasDefinition response.
func (client *Client) getSasDefinitionHandleResponse(resp *http.Response) (result ClientGetSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		result = ClientGetSasDefinitionResponse{}
		return
	}
	return result, nil
}

// NewGetSasDefinitionsPager - List storage SAS definitions for the given storage account. This operation requires the storage/listsas
// permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientGetSasDefinitionsOptions contains the optional parameters for the Client.NewGetSasDefinitionsPager method.
func (client *Client) NewGetSasDefinitionsPager(vaultBaseURL string, storageAccountName string, options *ClientGetSasDefinitionsOptions) *runtime.Pager[ClientGetSasDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSasDefinitionsResponse]{
		More: func(page ClientGetSasDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSasDefinitionsResponse) (result ClientGetSasDefinitionsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetSasDefinitionsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getSasDefinitionsCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getSasDefinitionsHandleResponse(resp)
			return
		},
	})
}

// getSasDefinitionsCreateRequest creates the GetSasDefinitions request.
func (client *Client) getSasDefinitionsCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetSasDefinitionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSasDefinitionsHandleResponse handles the GetSasDefinitions response.
func (client *Client) getSasDefinitionsHandleResponse(resp *http.Response) (result ClientGetSasDefinitionsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SasDefinitionListResult); err != nil {
		result = ClientGetSasDefinitionsResponse{}
		return
	}
	return result, nil
}

// GetSecret - The GET operation is applicable to any secret stored in Azure Key Vault. This operation requires the secrets/get
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - secretVersion - The version of the secret. This URI fragment is optional. If not specified, the latest version of the secret
//     is returned.
//   - options - ClientGetSecretOptions contains the optional parameters for the Client.GetSecret method.
func (client *Client) GetSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *ClientGetSecretOptions) (result ClientGetSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getSecretHandleResponse(resp)
	return
}

// getSecretCreateRequest creates the GetSecret request.
func (client *Client) getSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, options *ClientGetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretHandleResponse handles the GetSecret response.
func (client *Client) getSecretHandleResponse(resp *http.Response) (result ClientGetSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		result = ClientGetSecretResponse{}
		return
	}
	return result, nil
}

// NewGetSecretVersionsPager - The full secret identifier and attributes are provided in the response. No values are returned
// for the secrets. This operations requires the secrets/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - options - ClientGetSecretVersionsOptions contains the optional parameters for the Client.NewGetSecretVersionsPager method.
func (client *Client) NewGetSecretVersionsPager(vaultBaseURL string, secretName string, options *ClientGetSecretVersionsOptions) *runtime.Pager[ClientGetSecretVersionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSecretVersionsResponse]{
		More: func(page ClientGetSecretVersionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSecretVersionsResponse) (result ClientGetSecretVersionsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetSecretVersionsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getSecretVersionsCreateRequest(ctx, vaultBaseURL, secretName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getSecretVersionsHandleResponse(resp)
			return
		},
	})
}

// getSecretVersionsCreateRequest creates the GetSecretVersions request.
func (client *Client) getSecretVersionsCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientGetSecretVersionsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/versions"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretVersionsHandleResponse handles the GetSecretVersions response.
func (client *Client) getSecretVersionsHandleResponse(resp *http.Response) (result ClientGetSecretVersionsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretListResult); err != nil {
		result = ClientGetSecretVersionsResponse{}
		return
	}
	return result, nil
}

// NewGetSecretsPager - The Get Secrets operation is applicable to the entire vault. However, only the base secret identifier
// and its attributes are provided in the response. Individual secret versions are not listed in the
// response. This operation requires the secrets/list permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetSecretsOptions contains the optional parameters for the Client.NewGetSecretsPager method.
func (client *Client) NewGetSecretsPager(vaultBaseURL string, options *ClientGetSecretsOptions) *runtime.Pager[ClientGetSecretsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetSecretsResponse]{
		More: func(page ClientGetSecretsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetSecretsResponse) (result ClientGetSecretsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetSecretsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getSecretsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getSecretsHandleResponse(resp)
			return
		},
	})
}

// getSecretsCreateRequest creates the GetSecrets request.
func (client *Client) getSecretsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetSecretsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSecretsHandleResponse handles the GetSecrets response.
func (client *Client) getSecretsHandleResponse(resp *http.Response) (result ClientGetSecretsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretListResult); err != nil {
		result = ClientGetSecretsResponse{}
		return
	}
	return result, nil
}

// GetStorageAccount - Gets information about a specified storage account. This operation requires the storage/get permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientGetStorageAccountOptions contains the optional parameters for the Client.GetStorageAccount method.
func (client *Client) GetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetStorageAccountOptions) (result ClientGetStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.GetStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getStorageAccountHandleResponse(resp)
	return
}

// getStorageAccountCreateRequest creates the GetStorageAccount request.
func (client *Client) getStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientGetStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStorageAccountHandleResponse handles the GetStorageAccount response.
func (client *Client) getStorageAccountHandleResponse(resp *http.Response) (result ClientGetStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientGetStorageAccountResponse{}
		return
	}
	return result, nil
}

// NewGetStorageAccountsPager - List storage accounts managed by the specified key vault. This operation requires the storage/list
// permission.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - options - ClientGetStorageAccountsOptions contains the optional parameters for the Client.NewGetStorageAccountsPager method.
func (client *Client) NewGetStorageAccountsPager(vaultBaseURL string, options *ClientGetStorageAccountsOptions) *runtime.Pager[ClientGetStorageAccountsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientGetStorageAccountsResponse]{
		More: func(page ClientGetStorageAccountsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientGetStorageAccountsResponse) (result ClientGetStorageAccountsResponse, err error) {
			ctx, span := client.internal.Tracer().Start(ctx, "Client.NewGetStorageAccountsPager", &tracing.SpanOptions{
				Kind: tracing.SpanKindInternal,
			})
			defer func() {
				if err != nil {
					span.AddError(err)
				}
				span.End()
			}()
			var req *policy.Request
			if page == nil {
				req, err = client.getStorageAccountsCreateRequest(ctx, vaultBaseURL, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return
			}
			resp, err := client.internal.Pipeline().Do(req)
			if err != nil {
				return
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				err = runtime.NewResponseError(resp)
				return
			}
			result, err = client.getStorageAccountsHandleResponse(resp)
			return
		},
	})
}

// getStorageAccountsCreateRequest creates the GetStorageAccounts request.
func (client *Client) getStorageAccountsCreateRequest(ctx context.Context, vaultBaseURL string, options *ClientGetStorageAccountsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getStorageAccountsHandleResponse handles the GetStorageAccounts response.
func (client *Client) getStorageAccountsHandleResponse(resp *http.Response) (result ClientGetStorageAccountsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageListResult); err != nil {
		result = ClientGetStorageAccountsResponse{}
		return
	}
	return result, nil
}

// ImportCertificate - Imports an existing valid certificate, containing a private key, into Azure Key Vault. The certificate
// to be imported can be in either PFX or PEM format. If the certificate is in PEM format the PEM
// file must contain the key as well as x509 certificates. This operation requires the certificates/import permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - parameters - The parameters to import the certificate.
//   - options - ClientImportCertificateOptions contains the optional parameters for the Client.ImportCertificate method.
func (client *Client) ImportCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *ClientImportCertificateOptions) (result ClientImportCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.ImportCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.importCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.importCertificateHandleResponse(resp)
	return
}

// importCertificateCreateRequest creates the ImportCertificate request.
func (client *Client) importCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateImportParameters, options *ClientImportCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/import"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// importCertificateHandleResponse handles the ImportCertificate response.
func (client *Client) importCertificateHandleResponse(resp *http.Response) (result ClientImportCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientImportCertificateResponse{}
		return
	}
	return result, nil
}

// ImportKey - The import key operation may be used to import any key type into an Azure Key Vault. If the named key already
// exists, Azure Key Vault creates a new version of the key. This operation requires the
// keys/import permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - Name for the imported key.
//   - parameters - The parameters to import a key.
//   - options - ClientImportKeyOptions contains the optional parameters for the Client.ImportKey method.
func (client *Client) ImportKey(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *ClientImportKeyOptions) (result ClientImportKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.ImportKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.importKeyCreateRequest(ctx, vaultBaseURL, keyName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.importKeyHandleResponse(resp)
	return
}

// importKeyCreateRequest creates the ImportKey request.
func (client *Client) importKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, parameters KeyImportParameters, options *ClientImportKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// importKeyHandleResponse handles the ImportKey response.
func (client *Client) importKeyHandleResponse(resp *http.Response) (result ClientImportKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientImportKeyResponse{}
		return
	}
	return result, nil
}

// MergeCertificate - The MergeCertificate operation performs the merging of a certificate or certificate chain with a key
// pair currently available in the service. This operation requires the certificates/create
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - parameters - The parameters to merge certificate.
//   - options - ClientMergeCertificateOptions contains the optional parameters for the Client.MergeCertificate method.
func (client *Client) MergeCertificate(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *ClientMergeCertificateOptions) (result ClientMergeCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.MergeCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.mergeCertificateCreateRequest(ctx, vaultBaseURL, certificateName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.mergeCertificateHandleResponse(resp)
	return
}

// mergeCertificateCreateRequest creates the MergeCertificate request.
func (client *Client) mergeCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, parameters CertificateMergeParameters, options *ClientMergeCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending/merge"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// mergeCertificateHandleResponse handles the MergeCertificate response.
func (client *Client) mergeCertificateHandleResponse(resp *http.Response) (result ClientMergeCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientMergeCertificateResponse{}
		return
	}
	return result, nil
}

// PurgeDeletedCertificate - The PurgeDeletedCertificate operation performs an irreversible deletion of the specified certificate,
// without possibility for recovery. The operation is not available if the recovery level does not
// specify 'Purgeable'. This operation requires the certificate/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate
//   - options - ClientPurgeDeletedCertificateOptions contains the optional parameters for the Client.PurgeDeletedCertificate
//     method.
func (client *Client) PurgeDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientPurgeDeletedCertificateOptions) (result ClientPurgeDeletedCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.PurgeDeletedCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.purgeDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// purgeDeletedCertificateCreateRequest creates the PurgeDeletedCertificate request.
func (client *Client) purgeDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientPurgeDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedKey - The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can
// be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.
// This operation requires the keys/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key
//   - options - ClientPurgeDeletedKeyOptions contains the optional parameters for the Client.PurgeDeletedKey method.
func (client *Client) PurgeDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientPurgeDeletedKeyOptions) (result ClientPurgeDeletedKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.PurgeDeletedKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.purgeDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// purgeDeletedKeyCreateRequest creates the PurgeDeletedKey request.
func (client *Client) purgeDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientPurgeDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedSecret - The purge deleted secret operation removes the secret permanently, without the possibility of recovery.
// This operation can only be enabled on a soft-delete enabled vault. This operation requires the
// secrets/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - options - ClientPurgeDeletedSecretOptions contains the optional parameters for the Client.PurgeDeletedSecret method.
func (client *Client) PurgeDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientPurgeDeletedSecretOptions) (result ClientPurgeDeletedSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.PurgeDeletedSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.purgeDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// purgeDeletedSecretCreateRequest creates the PurgeDeletedSecret request.
func (client *Client) purgeDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientPurgeDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// PurgeDeletedStorageAccount - The purge deleted storage account operation removes the secret permanently, without the possibility
// of recovery. This operation can only be performed on a soft-delete enabled vault. This operation
// requires the storage/purge permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientPurgeDeletedStorageAccountOptions contains the optional parameters for the Client.PurgeDeletedStorageAccount
//     method.
func (client *Client) PurgeDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientPurgeDeletedStorageAccountOptions) (result ClientPurgeDeletedStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.PurgeDeletedStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.purgeDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// purgeDeletedStorageAccountCreateRequest creates the PurgeDeletedStorageAccount request.
func (client *Client) purgeDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientPurgeDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// RecoverDeletedCertificate - The RecoverDeletedCertificate operation performs the reversal of the Delete operation. The
// operation is applicable in vaults enabled for soft-delete, and must be issued during the retention interval
// (available in the deleted certificate's attributes). This operation requires the certificates/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the deleted certificate
//   - options - ClientRecoverDeletedCertificateOptions contains the optional parameters for the Client.RecoverDeletedCertificate
//     method.
func (client *Client) RecoverDeletedCertificate(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientRecoverDeletedCertificateOptions) (result ClientRecoverDeletedCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RecoverDeletedCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.recoverDeletedCertificateCreateRequest(ctx, vaultBaseURL, certificateName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.recoverDeletedCertificateHandleResponse(resp)
	return
}

// recoverDeletedCertificateCreateRequest creates the RecoverDeletedCertificate request.
func (client *Client) recoverDeletedCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, options *ClientRecoverDeletedCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedcertificates/{certificate-name}/recover"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedCertificateHandleResponse handles the RecoverDeletedCertificate response.
func (client *Client) recoverDeletedCertificateHandleResponse(resp *http.Response) (result ClientRecoverDeletedCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientRecoverDeletedCertificateResponse{}
		return
	}
	return result, nil
}

// RecoverDeletedKey - The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It
// recovers the deleted key back to its latest version under /keys. An attempt to recover an non-deleted
// key will return an error. Consider this the inverse of the delete operation on soft-delete enabled vaults. This operation
// requires the keys/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the deleted key.
//   - options - ClientRecoverDeletedKeyOptions contains the optional parameters for the Client.RecoverDeletedKey method.
func (client *Client) RecoverDeletedKey(ctx context.Context, vaultBaseURL string, keyName string, options *ClientRecoverDeletedKeyOptions) (result ClientRecoverDeletedKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RecoverDeletedKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.recoverDeletedKeyCreateRequest(ctx, vaultBaseURL, keyName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.recoverDeletedKeyHandleResponse(resp)
	return
}

// recoverDeletedKeyCreateRequest creates the RecoverDeletedKey request.
func (client *Client) recoverDeletedKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, options *ClientRecoverDeletedKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedkeys/{key-name}/recover"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedKeyHandleResponse handles the RecoverDeletedKey response.
func (client *Client) recoverDeletedKeyHandleResponse(resp *http.Response) (result ClientRecoverDeletedKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientRecoverDeletedKeyResponse{}
		return
	}
	return result, nil
}

// RecoverDeletedSasDefinition - Recovers the deleted SAS definition for the specified storage account. This operation can
// only be performed on a soft-delete enabled vault. This operation requires the storage/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - options - ClientRecoverDeletedSasDefinitionOptions contains the optional parameters for the Client.RecoverDeletedSasDefinition
//     method.
func (client *Client) RecoverDeletedSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientRecoverDeletedSasDefinitionOptions) (result ClientRecoverDeletedSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RecoverDeletedSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.recoverDeletedSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.recoverDeletedSasDefinitionHandleResponse(resp)
	return
}

// recoverDeletedSasDefinitionCreateRequest creates the RecoverDeletedSasDefinition request.
func (client *Client) recoverDeletedSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, options *ClientRecoverDeletedSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/sas/{sas-definition-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedSasDefinitionHandleResponse handles the RecoverDeletedSasDefinition response.
func (client *Client) recoverDeletedSasDefinitionHandleResponse(resp *http.Response) (result ClientRecoverDeletedSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		result = ClientRecoverDeletedSasDefinitionResponse{}
		return
	}
	return result, nil
}

// RecoverDeletedSecret - Recovers the deleted secret in the specified vault. This operation can only be performed on a soft-delete
// enabled vault. This operation requires the secrets/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the deleted secret.
//   - options - ClientRecoverDeletedSecretOptions contains the optional parameters for the Client.RecoverDeletedSecret method.
func (client *Client) RecoverDeletedSecret(ctx context.Context, vaultBaseURL string, secretName string, options *ClientRecoverDeletedSecretOptions) (result ClientRecoverDeletedSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RecoverDeletedSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.recoverDeletedSecretCreateRequest(ctx, vaultBaseURL, secretName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.recoverDeletedSecretHandleResponse(resp)
	return
}

// recoverDeletedSecretCreateRequest creates the RecoverDeletedSecret request.
func (client *Client) recoverDeletedSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, options *ClientRecoverDeletedSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedsecrets/{secret-name}/recover"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedSecretHandleResponse handles the RecoverDeletedSecret response.
func (client *Client) recoverDeletedSecretHandleResponse(resp *http.Response) (result ClientRecoverDeletedSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		result = ClientRecoverDeletedSecretResponse{}
		return
	}
	return result, nil
}

// RecoverDeletedStorageAccount - Recovers the deleted storage account in the specified vault. This operation can only be
// performed on a soft-delete enabled vault. This operation requires the storage/recover permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - options - ClientRecoverDeletedStorageAccountOptions contains the optional parameters for the Client.RecoverDeletedStorageAccount
//     method.
func (client *Client) RecoverDeletedStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientRecoverDeletedStorageAccountOptions) (result ClientRecoverDeletedStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RecoverDeletedStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.recoverDeletedStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.recoverDeletedStorageAccountHandleResponse(resp)
	return
}

// recoverDeletedStorageAccountCreateRequest creates the RecoverDeletedStorageAccount request.
func (client *Client) recoverDeletedStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, options *ClientRecoverDeletedStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/deletedstorage/{storage-account-name}/recover"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// recoverDeletedStorageAccountHandleResponse handles the RecoverDeletedStorageAccount response.
func (client *Client) recoverDeletedStorageAccountHandleResponse(resp *http.Response) (result ClientRecoverDeletedStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientRecoverDeletedStorageAccountResponse{}
		return
	}
	return result, nil
}

// RegenerateStorageAccountKey - Regenerates the specified key value for the given storage account. This operation requires
// the storage/regeneratekey permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - parameters - The parameters to regenerate storage account key.
//   - options - ClientRegenerateStorageAccountKeyOptions contains the optional parameters for the Client.RegenerateStorageAccountKey
//     method.
func (client *Client) RegenerateStorageAccountKey(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *ClientRegenerateStorageAccountKeyOptions) (result ClientRegenerateStorageAccountKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RegenerateStorageAccountKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.regenerateStorageAccountKeyCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.regenerateStorageAccountKeyHandleResponse(resp)
	return
}

// regenerateStorageAccountKeyCreateRequest creates the RegenerateStorageAccountKey request.
func (client *Client) regenerateStorageAccountKeyCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountRegenerteKeyParameters, options *ClientRegenerateStorageAccountKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/regeneratekey"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// regenerateStorageAccountKeyHandleResponse handles the RegenerateStorageAccountKey response.
func (client *Client) regenerateStorageAccountKeyHandleResponse(resp *http.Response) (result ClientRegenerateStorageAccountKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientRegenerateStorageAccountKeyResponse{}
		return
	}
	return result, nil
}

// RestoreCertificate - Restores a backed up certificate, and all its versions, to a vault. This operation requires the certificates/restore
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - parameters - The parameters to restore the certificate.
//   - options - ClientRestoreCertificateOptions contains the optional parameters for the Client.RestoreCertificate method.
func (client *Client) RestoreCertificate(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *ClientRestoreCertificateOptions) (result ClientRestoreCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RestoreCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.restoreCertificateCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.restoreCertificateHandleResponse(resp)
	return
}

// restoreCertificateCreateRequest creates the RestoreCertificate request.
func (client *Client) restoreCertificateCreateRequest(ctx context.Context, vaultBaseURL string, parameters CertificateRestoreParameters, options *ClientRestoreCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreCertificateHandleResponse handles the RestoreCertificate response.
func (client *Client) restoreCertificateHandleResponse(resp *http.Response) (result ClientRestoreCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientRestoreCertificateResponse{}
		return
	}
	return result, nil
}

// RestoreKey - Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier, attributes
// and access control policies. The RESTORE operation may be used to import a previously backed
// up key. Individual versions of a key cannot be restored. The key is restored in its entirety with the same key name as
// it had when it was backed up. If the key name is not available in the target Key
// Vault, the RESTORE operation will be rejected. While the key name is retained during restore, the final key identifier
// will change if the key is restored to a different vault. Restore will restore all
// versions and preserve version identifiers. The RESTORE operation is subject to security constraints: The target Key Vault
// must be owned by the same Microsoft Azure Subscription as the source Key Vault
// The user must have RESTORE permission in the target Key Vault. This operation requires the keys/restore permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - parameters - The parameters to restore the key.
//   - options - ClientRestoreKeyOptions contains the optional parameters for the Client.RestoreKey method.
func (client *Client) RestoreKey(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *ClientRestoreKeyOptions) (result ClientRestoreKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RestoreKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.restoreKeyCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.restoreKeyHandleResponse(resp)
	return
}

// restoreKeyCreateRequest creates the RestoreKey request.
func (client *Client) restoreKeyCreateRequest(ctx context.Context, vaultBaseURL string, parameters KeyRestoreParameters, options *ClientRestoreKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreKeyHandleResponse handles the RestoreKey response.
func (client *Client) restoreKeyHandleResponse(resp *http.Response) (result ClientRestoreKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientRestoreKeyResponse{}
		return
	}
	return result, nil
}

// RestoreSecret - Restores a backed up secret, and all its versions, to a vault. This operation requires the secrets/restore
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - parameters - The parameters to restore the secret.
//   - options - ClientRestoreSecretOptions contains the optional parameters for the Client.RestoreSecret method.
func (client *Client) RestoreSecret(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *ClientRestoreSecretOptions) (result ClientRestoreSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RestoreSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.restoreSecretCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.restoreSecretHandleResponse(resp)
	return
}

// restoreSecretCreateRequest creates the RestoreSecret request.
func (client *Client) restoreSecretCreateRequest(ctx context.Context, vaultBaseURL string, parameters SecretRestoreParameters, options *ClientRestoreSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreSecretHandleResponse handles the RestoreSecret response.
func (client *Client) restoreSecretHandleResponse(resp *http.Response) (result ClientRestoreSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		result = ClientRestoreSecretResponse{}
		return
	}
	return result, nil
}

// RestoreStatus - Returns the status of restore operation
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - jobID - The Job Id returned part of the restore operation
//   - options - ClientRestoreStatusOptions contains the optional parameters for the Client.RestoreStatus method.
func (client *Client) RestoreStatus(ctx context.Context, vaultBaseURL string, jobID string, options *ClientRestoreStatusOptions) (result ClientRestoreStatusResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RestoreStatus", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.restoreStatusCreateRequest(ctx, vaultBaseURL, jobID, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.restoreStatusHandleResponse(resp)
	return
}

// restoreStatusCreateRequest creates the RestoreStatus request.
func (client *Client) restoreStatusCreateRequest(ctx context.Context, vaultBaseURL string, jobID string, options *ClientRestoreStatusOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/restore/{jobId}/pending"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// restoreStatusHandleResponse handles the RestoreStatus response.
func (client *Client) restoreStatusHandleResponse(resp *http.Response) (result ClientRestoreStatusResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.RestoreOperation); err != nil {
		result = ClientRestoreStatusResponse{}
		return
	}
	return result, nil
}

// RestoreStorageAccount - Restores a backed up storage account to a vault. This operation requires the storage/restore permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - parameters - The parameters to restore the storage account.
//   - options - ClientRestoreStorageAccountOptions contains the optional parameters for the Client.RestoreStorageAccount method.
func (client *Client) RestoreStorageAccount(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *ClientRestoreStorageAccountOptions) (result ClientRestoreStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.RestoreStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.restoreStorageAccountCreateRequest(ctx, vaultBaseURL, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.restoreStorageAccountHandleResponse(resp)
	return
}

// restoreStorageAccountCreateRequest creates the RestoreStorageAccount request.
func (client *Client) restoreStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, parameters StorageRestoreParameters, options *ClientRestoreStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/restore"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// restoreStorageAccountHandleResponse handles the RestoreStorageAccount response.
func (client *Client) restoreStorageAccountHandleResponse(resp *http.Response) (result ClientRestoreStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientRestoreStorageAccountResponse{}
		return
	}
	return result, nil
}

// BeginSelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to
// a previously stored Azure Blob storage backup folder
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key to be restored from the user supplied backup
//   - restoreBlobDetails - The Azure blob SAS token pointing to a folder where the previous successful full backup was stored
//   - options - ClientBeginSelectiveKeyRestoreOperationOptions contains the optional parameters for the Client.BeginSelectiveKeyRestoreOperation
//     method.
func (client *Client) BeginSelectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (result *runtime.Poller[ClientSelectiveKeyRestoreOperationResponse], err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.BeginSelectiveKeyRestoreOperation", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	if options == nil || options.ResumeToken == "" {
		var resp *http.Response
		resp, err = client.selectiveKeyRestoreOperation(ctx, vaultBaseURL, keyName, restoreBlobDetails, options)
		if err != nil {
			return
		}
		result, err = runtime.NewPoller(resp, client.internal.Pipeline(), &runtime.NewPollerOptions[ClientSelectiveKeyRestoreOperationResponse]{
			FinalStateVia: runtime.FinalStateViaAzureAsyncOp,
		})
	} else {
		result, err = runtime.NewPollerFromResumeToken[ClientSelectiveKeyRestoreOperationResponse](options.ResumeToken, client.internal.Pipeline(), nil)
	}
	return
}

// SelectiveKeyRestoreOperation - Restores all key versions of a given key using user supplied SAS token pointing to a previously
// stored Azure Blob storage backup folder
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
func (client *Client) selectiveKeyRestoreOperation(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (resp *http.Response, err error) {
	req, err := client.selectiveKeyRestoreOperationCreateRequest(ctx, vaultBaseURL, keyName, restoreBlobDetails, options)
	if err != nil {
		return
	}
	resp, err = client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// selectiveKeyRestoreOperationCreateRequest creates the SelectiveKeyRestoreOperation request.
func (client *Client) selectiveKeyRestoreOperationCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, restoreBlobDetails SelectiveKeyRestoreOperationParameters, options *ClientBeginSelectiveKeyRestoreOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{keyName}/restore"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, restoreBlobDetails)
}

// SetCertificateContacts - Sets the certificate contacts for the specified key vault. This operation requires the certificates/managecontacts
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - contacts - The contacts for the key vault certificate.
//   - options - ClientSetCertificateContactsOptions contains the optional parameters for the Client.SetCertificateContacts method.
func (client *Client) SetCertificateContacts(ctx context.Context, vaultBaseURL string, contacts Contacts, options *ClientSetCertificateContactsOptions) (result ClientSetCertificateContactsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.SetCertificateContacts", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.setCertificateContactsCreateRequest(ctx, vaultBaseURL, contacts, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.setCertificateContactsHandleResponse(resp)
	return
}

// setCertificateContactsCreateRequest creates the SetCertificateContacts request.
func (client *Client) setCertificateContactsCreateRequest(ctx context.Context, vaultBaseURL string, contacts Contacts, options *ClientSetCertificateContactsOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/contacts"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, contacts)
}

// setCertificateContactsHandleResponse handles the SetCertificateContacts response.
func (client *Client) setCertificateContactsHandleResponse(resp *http.Response) (result ClientSetCertificateContactsResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.Contacts); err != nil {
		result = ClientSetCertificateContactsResponse{}
		return
	}
	return result, nil
}

// SetCertificateIssuer - The SetCertificateIssuer operation adds or updates the specified certificate issuer. This operation
// requires the certificates/setissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - issuerName - The name of the issuer.
//   - parameter - Certificate issuer set parameter.
//   - options - ClientSetCertificateIssuerOptions contains the optional parameters for the Client.SetCertificateIssuer method.
func (client *Client) SetCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *ClientSetCertificateIssuerOptions) (result ClientSetCertificateIssuerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.SetCertificateIssuer", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.setCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.setCertificateIssuerHandleResponse(resp)
	return
}

// setCertificateIssuerCreateRequest creates the SetCertificateIssuer request.
func (client *Client) setCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerSetParameters, options *ClientSetCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameter)
}

// setCertificateIssuerHandleResponse handles the SetCertificateIssuer response.
func (client *Client) setCertificateIssuerHandleResponse(resp *http.Response) (result ClientSetCertificateIssuerResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		result = ClientSetCertificateIssuerResponse{}
		return
	}
	return result, nil
}

// SetSasDefinition - Creates or updates a new SAS definition for the specified storage account. This operation requires the
// storage/setsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - parameters - The parameters to create a SAS definition.
//   - options - ClientSetSasDefinitionOptions contains the optional parameters for the Client.SetSasDefinition method.
func (client *Client) SetSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *ClientSetSasDefinitionOptions) (result ClientSetSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.SetSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.setSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.setSasDefinitionHandleResponse(resp)
	return
}

// setSasDefinitionCreateRequest creates the SetSasDefinition request.
func (client *Client) setSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionCreateParameters, options *ClientSetSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setSasDefinitionHandleResponse handles the SetSasDefinition response.
func (client *Client) setSasDefinitionHandleResponse(resp *http.Response) (result ClientSetSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		result = ClientSetSasDefinitionResponse{}
		return
	}
	return result, nil
}

// SetSecret - The SET operation adds a secret to the Azure Key Vault. If the named secret already exists, Azure Key Vault
// creates a new version of that secret. This operation requires the secrets/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - parameters - The parameters for setting the secret.
//   - options - ClientSetSecretOptions contains the optional parameters for the Client.SetSecret method.
func (client *Client) SetSecret(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *ClientSetSecretOptions) (result ClientSetSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.SetSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.setSecretCreateRequest(ctx, vaultBaseURL, secretName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.setSecretHandleResponse(resp)
	return
}

// setSecretCreateRequest creates the SetSecret request.
func (client *Client) setSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, parameters SecretSetParameters, options *ClientSetSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setSecretHandleResponse handles the SetSecret response.
func (client *Client) setSecretHandleResponse(resp *http.Response) (result ClientSetSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		result = ClientSetSecretResponse{}
		return
	}
	return result, nil
}

// SetStorageAccount - Creates or updates a new storage account. This operation requires the storage/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - parameters - The parameters to create a storage account.
//   - options - ClientSetStorageAccountOptions contains the optional parameters for the Client.SetStorageAccount method.
func (client *Client) SetStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *ClientSetStorageAccountOptions) (result ClientSetStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.SetStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.setStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.setStorageAccountHandleResponse(resp)
	return
}

// setStorageAccountCreateRequest creates the SetStorageAccount request.
func (client *Client) setStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountCreateParameters, options *ClientSetStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// setStorageAccountHandleResponse handles the SetStorageAccount response.
func (client *Client) setStorageAccountHandleResponse(resp *http.Response) (result ClientSetStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientSetStorageAccountResponse{}
		return
	}
	return result, nil
}

// Sign - The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since this operation
// uses the private portion of the key. This operation requires the keys/sign permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the signing operation.
//   - options - ClientSignOptions contains the optional parameters for the Client.Sign method.
func (client *Client) Sign(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *ClientSignOptions) (result ClientSignResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.Sign", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.signCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.signHandleResponse(resp)
	return
}

// signCreateRequest creates the Sign request.
func (client *Client) signCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeySignParameters, options *ClientSignOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/sign"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// signHandleResponse handles the Sign response.
func (client *Client) signHandleResponse(resp *http.Response) (result ClientSignResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		result = ClientSignResponse{}
		return
	}
	return result, nil
}

// UnwrapKey - The UNWRAP operation supports decryption of a symmetric key using the target key encryption key. This operation
// is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and
// symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This operation requires the keys/unwrapKey
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for the key operation.
//   - options - ClientUnwrapKeyOptions contains the optional parameters for the Client.UnwrapKey method.
func (client *Client) UnwrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientUnwrapKeyOptions) (result ClientUnwrapKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UnwrapKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.unwrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.unwrapKeyHandleResponse(resp)
	return
}

// unwrapKeyCreateRequest creates the UnwrapKey request.
func (client *Client) unwrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientUnwrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/unwrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// unwrapKeyHandleResponse handles the UnwrapKey response.
func (client *Client) unwrapKeyHandleResponse(resp *http.Response) (result ClientUnwrapKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		result = ClientUnwrapKeyResponse{}
		return
	}
	return result, nil
}

// UpdateCertificate - The UpdateCertificate operation applies the specified update on the given certificate; the only elements
// updated are the certificate's attributes. This operation requires the certificates/update
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate in the given key vault.
//   - certificateVersion - The version of the certificate.
//   - parameters - The parameters for certificate update.
//   - options - ClientUpdateCertificateOptions contains the optional parameters for the Client.UpdateCertificate method.
func (client *Client) UpdateCertificate(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *ClientUpdateCertificateOptions) (result ClientUpdateCertificateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateCertificate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateCertificateCreateRequest(ctx, vaultBaseURL, certificateName, certificateVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateCertificateHandleResponse(resp)
	return
}

// updateCertificateCreateRequest creates the UpdateCertificate request.
func (client *Client) updateCertificateCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateVersion string, parameters CertificateUpdateParameters, options *ClientUpdateCertificateOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/{certificate-version}"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	if certificateVersion == "" {
		return nil, errors.New("parameter certificateVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-version}", url.PathEscape(certificateVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateCertificateHandleResponse handles the UpdateCertificate response.
func (client *Client) updateCertificateHandleResponse(resp *http.Response) (result ClientUpdateCertificateResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateBundle); err != nil {
		result = ClientUpdateCertificateResponse{}
		return
	}
	return result, nil
}

// UpdateCertificateIssuer - The UpdateCertificateIssuer operation performs an update on the specified certificate issuer
// entity. This operation requires the certificates/setissuers permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - issuerName - The name of the issuer.
//   - parameter - Certificate issuer update parameter.
//   - options - ClientUpdateCertificateIssuerOptions contains the optional parameters for the Client.UpdateCertificateIssuer
//     method.
func (client *Client) UpdateCertificateIssuer(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *ClientUpdateCertificateIssuerOptions) (result ClientUpdateCertificateIssuerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateCertificateIssuer", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateCertificateIssuerCreateRequest(ctx, vaultBaseURL, issuerName, parameter, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateCertificateIssuerHandleResponse(resp)
	return
}

// updateCertificateIssuerCreateRequest creates the UpdateCertificateIssuer request.
func (client *Client) updateCertificateIssuerCreateRequest(ctx context.Context, vaultBaseURL string, issuerName string, parameter CertificateIssuerUpdateParameters, options *ClientUpdateCertificateIssuerOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/issuers/{issuer-name}"
	if issuerName == "" {
		return nil, errors.New("parameter issuerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{issuer-name}", url.PathEscape(issuerName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameter)
}

// updateCertificateIssuerHandleResponse handles the UpdateCertificateIssuer response.
func (client *Client) updateCertificateIssuerHandleResponse(resp *http.Response) (result ClientUpdateCertificateIssuerResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.IssuerBundle); err != nil {
		result = ClientUpdateCertificateIssuerResponse{}
		return
	}
	return result, nil
}

// UpdateCertificateOperation - Updates a certificate creation operation that is already in progress. This operation requires
// the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate.
//   - certificateOperation - The certificate operation response.
//   - options - ClientUpdateCertificateOperationOptions contains the optional parameters for the Client.UpdateCertificateOperation
//     method.
func (client *Client) UpdateCertificateOperation(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *ClientUpdateCertificateOperationOptions) (result ClientUpdateCertificateOperationResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateCertificateOperation", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateCertificateOperationCreateRequest(ctx, vaultBaseURL, certificateName, certificateOperation, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateCertificateOperationHandleResponse(resp)
	return
}

// updateCertificateOperationCreateRequest creates the UpdateCertificateOperation request.
func (client *Client) updateCertificateOperationCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificateOperation CertificateOperationUpdateParameter, options *ClientUpdateCertificateOperationOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/pending"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, certificateOperation)
}

// updateCertificateOperationHandleResponse handles the UpdateCertificateOperation response.
func (client *Client) updateCertificateOperationHandleResponse(resp *http.Response) (result ClientUpdateCertificateOperationResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificateOperation); err != nil {
		result = ClientUpdateCertificateOperationResponse{}
		return
	}
	return result, nil
}

// UpdateCertificatePolicy - Set specified members in the certificate policy. Leave others as null. This operation requires
// the certificates/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - certificateName - The name of the certificate in the given vault.
//   - certificatePolicy - The policy for the certificate.
//   - options - ClientUpdateCertificatePolicyOptions contains the optional parameters for the Client.UpdateCertificatePolicy
//     method.
func (client *Client) UpdateCertificatePolicy(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *ClientUpdateCertificatePolicyOptions) (result ClientUpdateCertificatePolicyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateCertificatePolicy", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateCertificatePolicyCreateRequest(ctx, vaultBaseURL, certificateName, certificatePolicy, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateCertificatePolicyHandleResponse(resp)
	return
}

// updateCertificatePolicyCreateRequest creates the UpdateCertificatePolicy request.
func (client *Client) updateCertificatePolicyCreateRequest(ctx context.Context, vaultBaseURL string, certificateName string, certificatePolicy CertificatePolicy, options *ClientUpdateCertificatePolicyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/certificates/{certificate-name}/policy"
	if certificateName == "" {
		return nil, errors.New("parameter certificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{certificate-name}", url.PathEscape(certificateName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, certificatePolicy)
}

// updateCertificatePolicyHandleResponse handles the UpdateCertificatePolicy response.
func (client *Client) updateCertificatePolicyHandleResponse(resp *http.Response) (result ClientUpdateCertificatePolicyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.CertificatePolicy); err != nil {
		result = ClientUpdateCertificatePolicyResponse{}
		return
	}
	return result, nil
}

// UpdateKey - In order to perform this operation, the key must already exist in the Key Vault. Note: The cryptographic material
// of a key itself cannot be changed. This operation requires the keys/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of key to update.
//   - keyVersion - The version of the key to update.
//   - parameters - The parameters of the key to update.
//   - options - ClientUpdateKeyOptions contains the optional parameters for the Client.UpdateKey method.
func (client *Client) UpdateKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *ClientUpdateKeyOptions) (result ClientUpdateKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateKeyHandleResponse(resp)
	return
}

// updateKeyCreateRequest creates the UpdateKey request.
func (client *Client) updateKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyUpdateParameters, options *ClientUpdateKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateKeyHandleResponse handles the UpdateKey response.
func (client *Client) updateKeyHandleResponse(resp *http.Response) (result ClientUpdateKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyBundle); err != nil {
		result = ClientUpdateKeyResponse{}
		return
	}
	return result, nil
}

// UpdateSasDefinition - Updates the specified attributes associated with the given SAS definition. This operation requires
// the storage/setsas permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - sasDefinitionName - The name of the SAS definition.
//   - parameters - The parameters to update a SAS definition.
//   - options - ClientUpdateSasDefinitionOptions contains the optional parameters for the Client.UpdateSasDefinition method.
func (client *Client) UpdateSasDefinition(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *ClientUpdateSasDefinitionOptions) (result ClientUpdateSasDefinitionResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateSasDefinition", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateSasDefinitionCreateRequest(ctx, vaultBaseURL, storageAccountName, sasDefinitionName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateSasDefinitionHandleResponse(resp)
	return
}

// updateSasDefinitionCreateRequest creates the UpdateSasDefinition request.
func (client *Client) updateSasDefinitionCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, sasDefinitionName string, parameters SasDefinitionUpdateParameters, options *ClientUpdateSasDefinitionOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}/sas/{sas-definition-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	if sasDefinitionName == "" {
		return nil, errors.New("parameter sasDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sas-definition-name}", url.PathEscape(sasDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateSasDefinitionHandleResponse handles the UpdateSasDefinition response.
func (client *Client) updateSasDefinitionHandleResponse(resp *http.Response) (result ClientUpdateSasDefinitionResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SasDefinitionBundle); err != nil {
		result = ClientUpdateSasDefinitionResponse{}
		return
	}
	return result, nil
}

// UpdateSecret - The UPDATE operation changes specified attributes of an existing stored secret. Attributes that are not
// specified in the request are left unchanged. The value of a secret itself cannot be changed.
// This operation requires the secrets/set permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - secretName - The name of the secret.
//   - secretVersion - The version of the secret.
//   - parameters - The parameters for update secret operation.
//   - options - ClientUpdateSecretOptions contains the optional parameters for the Client.UpdateSecret method.
func (client *Client) UpdateSecret(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *ClientUpdateSecretOptions) (result ClientUpdateSecretResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateSecret", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateSecretCreateRequest(ctx, vaultBaseURL, secretName, secretVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateSecretHandleResponse(resp)
	return
}

// updateSecretCreateRequest creates the UpdateSecret request.
func (client *Client) updateSecretCreateRequest(ctx context.Context, vaultBaseURL string, secretName string, secretVersion string, parameters SecretUpdateParameters, options *ClientUpdateSecretOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/secrets/{secret-name}/{secret-version}"
	if secretName == "" {
		return nil, errors.New("parameter secretName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-name}", url.PathEscape(secretName))
	if secretVersion == "" {
		return nil, errors.New("parameter secretVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{secret-version}", url.PathEscape(secretVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateSecretHandleResponse handles the UpdateSecret response.
func (client *Client) updateSecretHandleResponse(resp *http.Response) (result ClientUpdateSecretResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.SecretBundle); err != nil {
		result = ClientUpdateSecretResponse{}
		return
	}
	return result, nil
}

// UpdateStorageAccount - Updates the specified attributes associated with the given storage account. This operation requires
// the storage/set/update permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - storageAccountName - The name of the storage account.
//   - parameters - The parameters to update a storage account.
//   - options - ClientUpdateStorageAccountOptions contains the optional parameters for the Client.UpdateStorageAccount method.
func (client *Client) UpdateStorageAccount(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *ClientUpdateStorageAccountOptions) (result ClientUpdateStorageAccountResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.UpdateStorageAccount", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.updateStorageAccountCreateRequest(ctx, vaultBaseURL, storageAccountName, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.updateStorageAccountHandleResponse(resp)
	return
}

// updateStorageAccountCreateRequest creates the UpdateStorageAccount request.
func (client *Client) updateStorageAccountCreateRequest(ctx context.Context, vaultBaseURL string, storageAccountName string, parameters StorageAccountUpdateParameters, options *ClientUpdateStorageAccountOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/storage/{storage-account-name}"
	if storageAccountName == "" {
		return nil, errors.New("parameter storageAccountName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{storage-account-name}", url.PathEscape(storageAccountName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateStorageAccountHandleResponse handles the UpdateStorageAccount response.
func (client *Client) updateStorageAccountHandleResponse(resp *http.Response) (result ClientUpdateStorageAccountResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.StorageBundle); err != nil {
		result = ClientUpdateStorageAccountResponse{}
		return
	}
	return result, nil
}

// Verify - The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not strictly necessary
// for asymmetric keys stored in Azure Key Vault since signature verification can be
// performed using the public portion of the key but this operation is supported as a convenience for callers that only have
// a key-reference and not the public portion of the key. This operation requires
// the keys/verify permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for verify operations.
//   - options - ClientVerifyOptions contains the optional parameters for the Client.Verify method.
func (client *Client) Verify(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *ClientVerifyOptions) (result ClientVerifyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.Verify", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.verifyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.verifyHandleResponse(resp)
	return
}

// verifyCreateRequest creates the Verify request.
func (client *Client) verifyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyVerifyParameters, options *ClientVerifyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/verify"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// verifyHandleResponse handles the Verify response.
func (client *Client) verifyHandleResponse(resp *http.Response) (result ClientVerifyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyVerifyResult); err != nil {
		result = ClientVerifyResponse{}
		return
	}
	return result, nil
}

// WrapKey - The WRAP operation supports encryption of a symmetric key using a key encryption key that has previously been
// stored in an Azure Key Vault. The WRAP operation is only strictly necessary for symmetric
// keys stored in Azure Key Vault since protection with an asymmetric key can be performed using the public portion of the
// key. This operation is supported for asymmetric keys as a convenience for
// callers that have a key-reference but do not have access to the public key material. This operation requires the keys/wrapKey
// permission.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 7.2
//   - vaultBaseURL - The vault name, for example https://myvault.vault.azure.net.
//   - keyName - The name of the key.
//   - keyVersion - The version of the key.
//   - parameters - The parameters for wrap operation.
//   - options - ClientWrapKeyOptions contains the optional parameters for the Client.WrapKey method.
func (client *Client) WrapKey(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientWrapKeyOptions) (result ClientWrapKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "Client.WrapKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.wrapKeyCreateRequest(ctx, vaultBaseURL, keyName, keyVersion, parameters, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.wrapKeyHandleResponse(resp)
	return
}

// wrapKeyCreateRequest creates the WrapKey request.
func (client *Client) wrapKeyCreateRequest(ctx context.Context, vaultBaseURL string, keyName string, keyVersion string, parameters KeyOperationsParameters, options *ClientWrapKeyOptions) (*policy.Request, error) {
	host := "{vaultBaseUrl}"
	host = strings.ReplaceAll(host, "{vaultBaseUrl}", vaultBaseURL)
	urlPath := "/keys/{key-name}/{key-version}/wrapkey"
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-name}", url.PathEscape(keyName))
	if keyVersion == "" {
		return nil, errors.New("parameter keyVersion cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{key-version}", url.PathEscape(keyVersion))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.2")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// wrapKeyHandleResponse handles the WrapKey response.
func (client *Client) wrapKeyHandleResponse(resp *http.Response) (result ClientWrapKeyResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.KeyOperationResult); err != nil {
		result = ClientWrapKeyResponse{}
		return
	}
	return result, nil
}
