//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package xmlgroup

import (
	"context"
	"encoding/xml"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
)

// XMLClient contains the methods for the XML group.
// Don't use this type directly, use a constructor function instead.
type XMLClient struct {
	internal *azcore.Client
}

// GetACLs - Gets storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetACLsOptions contains the optional parameters for the XMLClient.GetACLs method.
func (client *XMLClient) GetACLs(ctx context.Context, options *XMLClientGetACLsOptions) (result XMLClientGetACLsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetACLs", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getACLsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getACLsHandleResponse(resp)
	return
}

// getACLsCreateRequest creates the GetACLs request.
func (client *XMLClient) getACLsCreateRequest(ctx context.Context, options *XMLClientGetACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getACLsHandleResponse handles the GetACLs response.
func (client *XMLClient) getACLsHandleResponse(resp *http.Response) (result XMLClientGetACLsResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result); err != nil {
		result = XMLClientGetACLsResponse{}
		return
	}
	return result, nil
}

// GetBytes - Get an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetBytesOptions contains the optional parameters for the XMLClient.GetBytes method.
func (client *XMLClient) GetBytes(ctx context.Context, options *XMLClientGetBytesOptions) (result XMLClientGetBytesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetBytes", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getBytesCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getBytesHandleResponse(resp)
	return
}

// getBytesCreateRequest creates the GetBytes request.
func (client *XMLClient) getBytesCreateRequest(ctx context.Context, options *XMLClientGetBytesOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getBytesHandleResponse handles the GetBytes response.
func (client *XMLClient) getBytesHandleResponse(resp *http.Response) (result XMLClientGetBytesResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.ModelWithByteProperty); err != nil {
		result = XMLClientGetBytesResponse{}
		return
	}
	return result, nil
}

// GetComplexTypeRefNoMeta - Get a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefNoMeta
//     method.
func (client *XMLClient) GetComplexTypeRefNoMeta(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (result XMLClientGetComplexTypeRefNoMetaResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetComplexTypeRefNoMeta", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getComplexTypeRefNoMetaCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getComplexTypeRefNoMetaHandleResponse(resp)
	return
}

// getComplexTypeRefNoMetaCreateRequest creates the GetComplexTypeRefNoMeta request.
func (client *XMLClient) getComplexTypeRefNoMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefNoMetaHandleResponse handles the GetComplexTypeRefNoMeta response.
func (client *XMLClient) getComplexTypeRefNoMetaHandleResponse(resp *http.Response) (result XMLClientGetComplexTypeRefNoMetaResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.RootWithRefAndNoMeta); err != nil {
		result = XMLClientGetComplexTypeRefNoMetaResponse{}
		return
	}
	return result, nil
}

// GetComplexTypeRefWithMeta - Get a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.GetComplexTypeRefWithMeta
//     method.
func (client *XMLClient) GetComplexTypeRefWithMeta(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (result XMLClientGetComplexTypeRefWithMetaResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetComplexTypeRefWithMeta", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getComplexTypeRefWithMetaCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getComplexTypeRefWithMetaHandleResponse(resp)
	return
}

// getComplexTypeRefWithMetaCreateRequest creates the GetComplexTypeRefWithMeta request.
func (client *XMLClient) getComplexTypeRefWithMetaCreateRequest(ctx context.Context, options *XMLClientGetComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getComplexTypeRefWithMetaHandleResponse handles the GetComplexTypeRefWithMeta response.
func (client *XMLClient) getComplexTypeRefWithMetaHandleResponse(resp *http.Response) (result XMLClientGetComplexTypeRefWithMetaResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.RootWithRefAndMeta); err != nil {
		result = XMLClientGetComplexTypeRefWithMetaResponse{}
		return
	}
	return result, nil
}

// GetEmptyChildElement - Gets an XML document with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyChildElementOptions contains the optional parameters for the XMLClient.GetEmptyChildElement
//     method.
func (client *XMLClient) GetEmptyChildElement(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (result XMLClientGetEmptyChildElementResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetEmptyChildElement", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getEmptyChildElementCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getEmptyChildElementHandleResponse(resp)
	return
}

// getEmptyChildElementCreateRequest creates the GetEmptyChildElement request.
func (client *XMLClient) getEmptyChildElementCreateRequest(ctx context.Context, options *XMLClientGetEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyChildElementHandleResponse handles the GetEmptyChildElement response.
func (client *XMLClient) getEmptyChildElementHandleResponse(resp *http.Response) (result XMLClientGetEmptyChildElementResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.Banana); err != nil {
		result = XMLClientGetEmptyChildElementResponse{}
		return
	}
	return result, nil
}

// GetEmptyList - Get an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyListOptions contains the optional parameters for the XMLClient.GetEmptyList method.
func (client *XMLClient) GetEmptyList(ctx context.Context, options *XMLClientGetEmptyListOptions) (result XMLClientGetEmptyListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetEmptyList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getEmptyListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getEmptyListHandleResponse(resp)
	return
}

// getEmptyListCreateRequest creates the GetEmptyList request.
func (client *XMLClient) getEmptyListCreateRequest(ctx context.Context, options *XMLClientGetEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyListHandleResponse handles the GetEmptyList response.
func (client *XMLClient) getEmptyListHandleResponse(resp *http.Response) (result XMLClientGetEmptyListResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		result = XMLClientGetEmptyListResponse{}
		return
	}
	return result, nil
}

// GetEmptyRootList - Gets an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyRootListOptions contains the optional parameters for the XMLClient.GetEmptyRootList method.
func (client *XMLClient) GetEmptyRootList(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (result XMLClientGetEmptyRootListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetEmptyRootList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getEmptyRootListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getEmptyRootListHandleResponse(resp)
	return
}

// getEmptyRootListCreateRequest creates the GetEmptyRootList request.
func (client *XMLClient) getEmptyRootListCreateRequest(ctx context.Context, options *XMLClientGetEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyRootListHandleResponse handles the GetEmptyRootList response.
func (client *XMLClient) getEmptyRootListHandleResponse(resp *http.Response) (result XMLClientGetEmptyRootListResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result); err != nil {
		result = XMLClientGetEmptyRootListResponse{}
		return
	}
	return result, nil
}

// GetEmptyWrappedLists - Gets some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetEmptyWrappedListsOptions contains the optional parameters for the XMLClient.GetEmptyWrappedLists
//     method.
func (client *XMLClient) GetEmptyWrappedLists(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (result XMLClientGetEmptyWrappedListsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetEmptyWrappedLists", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getEmptyWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getEmptyWrappedListsHandleResponse(resp)
	return
}

// getEmptyWrappedListsCreateRequest creates the GetEmptyWrappedLists request.
func (client *XMLClient) getEmptyWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getEmptyWrappedListsHandleResponse handles the GetEmptyWrappedLists response.
func (client *XMLClient) getEmptyWrappedListsHandleResponse(resp *http.Response) (result XMLClientGetEmptyWrappedListsResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		result = XMLClientGetEmptyWrappedListsResponse{}
		return
	}
	return result, nil
}

// GetHeaders - Get strongly-typed response headers.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetHeadersOptions contains the optional parameters for the XMLClient.GetHeaders method.
func (client *XMLClient) GetHeaders(ctx context.Context, options *XMLClientGetHeadersOptions) (result XMLClientGetHeadersResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetHeaders", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getHeadersCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getHeadersHandleResponse(resp)
	return
}

// getHeadersCreateRequest creates the GetHeaders request.
func (client *XMLClient) getHeadersCreateRequest(ctx context.Context, options *XMLClientGetHeadersOptions) (*policy.Request, error) {
	urlPath := "/xml/headers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, nil
}

// getHeadersHandleResponse handles the GetHeaders response.
func (client *XMLClient) getHeadersHandleResponse(resp *http.Response) (result XMLClientGetHeadersResponse, err error) {
	if val := resp.Header.Get("Custom-Header"); val != "" {
		result.CustomHeader = &val
	}
	return result, nil
}

// GetRootList - Gets a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetRootListOptions contains the optional parameters for the XMLClient.GetRootList method.
func (client *XMLClient) GetRootList(ctx context.Context, options *XMLClientGetRootListOptions) (result XMLClientGetRootListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetRootList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getRootListCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getRootListHandleResponse(resp)
	return
}

// getRootListCreateRequest creates the GetRootList request.
func (client *XMLClient) getRootListCreateRequest(ctx context.Context, options *XMLClientGetRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListHandleResponse handles the GetRootList response.
func (client *XMLClient) getRootListHandleResponse(resp *http.Response) (result XMLClientGetRootListResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result); err != nil {
		result = XMLClientGetRootListResponse{}
		return
	}
	return result, nil
}

// GetRootListSingleItem - Gets a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetRootListSingleItemOptions contains the optional parameters for the XMLClient.GetRootListSingleItem
//     method.
func (client *XMLClient) GetRootListSingleItem(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (result XMLClientGetRootListSingleItemResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetRootListSingleItem", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getRootListSingleItemCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getRootListSingleItemHandleResponse(resp)
	return
}

// getRootListSingleItemCreateRequest creates the GetRootListSingleItem request.
func (client *XMLClient) getRootListSingleItemCreateRequest(ctx context.Context, options *XMLClientGetRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRootListSingleItemHandleResponse handles the GetRootListSingleItem response.
func (client *XMLClient) getRootListSingleItemHandleResponse(resp *http.Response) (result XMLClientGetRootListSingleItemResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result); err != nil {
		result = XMLClientGetRootListSingleItemResponse{}
		return
	}
	return result, nil
}

// GetServiceProperties - Gets storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetServicePropertiesOptions contains the optional parameters for the XMLClient.GetServiceProperties
//     method.
func (client *XMLClient) GetServiceProperties(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (result XMLClientGetServicePropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetServiceProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getServicePropertiesCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getServicePropertiesHandleResponse(resp)
	return
}

// getServicePropertiesCreateRequest creates the GetServiceProperties request.
func (client *XMLClient) getServicePropertiesCreateRequest(ctx context.Context, options *XMLClientGetServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getServicePropertiesHandleResponse handles the GetServiceProperties response.
func (client *XMLClient) getServicePropertiesHandleResponse(resp *http.Response) (result XMLClientGetServicePropertiesResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.StorageServiceProperties); err != nil {
		result = XMLClientGetServicePropertiesResponse{}
		return
	}
	return result, nil
}

// GetSimple - Get a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetSimpleOptions contains the optional parameters for the XMLClient.GetSimple method.
func (client *XMLClient) GetSimple(ctx context.Context, options *XMLClientGetSimpleOptions) (result XMLClientGetSimpleResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetSimple", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getSimpleCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getSimpleHandleResponse(resp)
	return
}

// getSimpleCreateRequest creates the GetSimple request.
func (client *XMLClient) getSimpleCreateRequest(ctx context.Context, options *XMLClientGetSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getSimpleHandleResponse handles the GetSimple response.
func (client *XMLClient) getSimpleHandleResponse(resp *http.Response) (result XMLClientGetSimpleResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.Slideshow); err != nil {
		result = XMLClientGetSimpleResponse{}
		return
	}
	return result, nil
}

// GetURI - Get an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetURIOptions contains the optional parameters for the XMLClient.GetURI method.
func (client *XMLClient) GetURI(ctx context.Context, options *XMLClientGetURIOptions) (result XMLClientGetURIResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetURI", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getURICreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getURIHandleResponse(resp)
	return
}

// getURICreateRequest creates the GetURI request.
func (client *XMLClient) getURICreateRequest(ctx context.Context, options *XMLClientGetURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getURIHandleResponse handles the GetURI response.
func (client *XMLClient) getURIHandleResponse(resp *http.Response) (result XMLClientGetURIResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.ModelWithURLProperty); err != nil {
		result = XMLClientGetURIResponse{}
		return
	}
	return result, nil
}

// GetWrappedLists - Get an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetWrappedListsOptions contains the optional parameters for the XMLClient.GetWrappedLists method.
func (client *XMLClient) GetWrappedLists(ctx context.Context, options *XMLClientGetWrappedListsOptions) (result XMLClientGetWrappedListsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetWrappedLists", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getWrappedListsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getWrappedListsHandleResponse(resp)
	return
}

// getWrappedListsCreateRequest creates the GetWrappedLists request.
func (client *XMLClient) getWrappedListsCreateRequest(ctx context.Context, options *XMLClientGetWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getWrappedListsHandleResponse handles the GetWrappedLists response.
func (client *XMLClient) getWrappedListsHandleResponse(resp *http.Response) (result XMLClientGetWrappedListsResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.AppleBarrel); err != nil {
		result = XMLClientGetWrappedListsResponse{}
		return
	}
	return result, nil
}

// GetXMsText - Get back an XML object with an x-ms-text property, which should translate to the returned object's 'language'
// property being 'english' and its 'content' property being 'I am text'
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientGetXMsTextOptions contains the optional parameters for the XMLClient.GetXMsText method.
func (client *XMLClient) GetXMsText(ctx context.Context, options *XMLClientGetXMsTextOptions) (result XMLClientGetXMsTextResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.GetXMsText", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getXMsTextCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getXMsTextHandleResponse(resp)
	return
}

// getXMsTextCreateRequest creates the GetXMsText request.
func (client *XMLClient) getXMsTextCreateRequest(ctx context.Context, options *XMLClientGetXMsTextOptions) (*policy.Request, error) {
	urlPath := "/xml/x-ms-text"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getXMsTextHandleResponse handles the GetXMsText response.
func (client *XMLClient) getXMsTextHandleResponse(resp *http.Response) (result XMLClientGetXMsTextResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.ObjectWithXMsTextProperty); err != nil {
		result = XMLClientGetXMsTextResponse{}
		return
	}
	return result, nil
}

// JSONInput - A Swagger with XML that has one operation that takes JSON as input. You need to send the ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientJSONInputOptions contains the optional parameters for the XMLClient.JSONInput method.
func (client *XMLClient) JSONInput(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (result XMLClientJSONInputResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.JSONInput", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.jsonInputCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// jsonInputCreateRequest creates the JSONInput request.
func (client *XMLClient) jsonInputCreateRequest(ctx context.Context, properties JSONInput, options *XMLClientJSONInputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsoninput"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsJSON(req, properties)
}

// JSONOutput - A Swagger with XML that has one operation that returns JSON. ID number 42
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientJSONOutputOptions contains the optional parameters for the XMLClient.JSONOutput method.
func (client *XMLClient) JSONOutput(ctx context.Context, options *XMLClientJSONOutputOptions) (result XMLClientJSONOutputResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.JSONOutput", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.jsonOutputCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.jsonOutputHandleResponse(resp)
	return
}

// jsonOutputCreateRequest creates the JSONOutput request.
func (client *XMLClient) jsonOutputCreateRequest(ctx context.Context, options *XMLClientJSONOutputOptions) (*policy.Request, error) {
	urlPath := "/xml/jsonoutput"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// jsonOutputHandleResponse handles the JSONOutput response.
func (client *XMLClient) jsonOutputHandleResponse(resp *http.Response) (result XMLClientJSONOutputResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.JSONOutput); err != nil {
		result = XMLClientJSONOutputResponse{}
		return
	}
	return result, nil
}

// ListBlobs - Lists blobs in a storage container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientListBlobsOptions contains the optional parameters for the XMLClient.ListBlobs method.
func (client *XMLClient) ListBlobs(ctx context.Context, options *XMLClientListBlobsOptions) (result XMLClientListBlobsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.ListBlobs", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.listBlobsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.listBlobsHandleResponse(resp)
	return
}

// listBlobsCreateRequest creates the ListBlobs request.
func (client *XMLClient) listBlobsCreateRequest(ctx context.Context, options *XMLClientListBlobsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listBlobsHandleResponse handles the ListBlobs response.
func (client *XMLClient) listBlobsHandleResponse(resp *http.Response) (result XMLClientListBlobsResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.ListBlobsResponse); err != nil {
		result = XMLClientListBlobsResponse{}
		return
	}
	return result, nil
}

// ListContainers - Lists containers in a storage account.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientListContainersOptions contains the optional parameters for the XMLClient.ListContainers method.
func (client *XMLClient) ListContainers(ctx context.Context, options *XMLClientListContainersOptions) (result XMLClientListContainersResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.ListContainers", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.listContainersCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.listContainersHandleResponse(resp)
	return
}

// listContainersCreateRequest creates the ListContainers request.
func (client *XMLClient) listContainersCreateRequest(ctx context.Context, options *XMLClientListContainersOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "list")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listContainersHandleResponse handles the ListContainers response.
func (client *XMLClient) listContainersHandleResponse(resp *http.Response) (result XMLClientListContainersResponse, err error) {
	if err = runtime.UnmarshalAsXML(resp, &result.ListContainersResponse); err != nil {
		result = XMLClientListContainersResponse{}
		return
	}
	return result, nil
}

// PutACLs - Puts storage ACLs for a container.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutACLsOptions contains the optional parameters for the XMLClient.PutACLs method.
func (client *XMLClient) PutACLs(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (result XMLClientPutACLsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutACLs", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putACLsCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putACLsCreateRequest creates the PutACLs request.
func (client *XMLClient) putACLsCreateRequest(ctx context.Context, properties []*SignedIdentifier, options *XMLClientPutACLsOptions) (*policy.Request, error) {
	urlPath := "/xml/mycontainer"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "acl")
	reqQP.Set("restype", "container")
	req.Raw().URL.RawQuery = reqQP.Encode()
	type wrapper struct {
		XMLName    xml.Name             `xml:"SignedIdentifiers"`
		Properties *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Properties: &properties})
}

// PutBinary - Put an XML document with binary property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutBinaryOptions contains the optional parameters for the XMLClient.PutBinary method.
func (client *XMLClient) PutBinary(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (result XMLClientPutBinaryResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutBinary", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putBinaryCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putBinaryCreateRequest creates the PutBinary request.
func (client *XMLClient) putBinaryCreateRequest(ctx context.Context, slideshow ModelWithByteProperty, options *XMLClientPutBinaryOptions) (*policy.Request, error) {
	urlPath := "/xml/bytes"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutComplexTypeRefNoMeta - Puts a complex type that has a ref to a complex type with no XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutComplexTypeRefNoMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefNoMeta
//     method.
func (client *XMLClient) PutComplexTypeRefNoMeta(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (result XMLClientPutComplexTypeRefNoMetaResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutComplexTypeRefNoMeta", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putComplexTypeRefNoMetaCreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putComplexTypeRefNoMetaCreateRequest creates the PutComplexTypeRefNoMeta request.
func (client *XMLClient) putComplexTypeRefNoMetaCreateRequest(ctx context.Context, model RootWithRefAndNoMeta, options *XMLClientPutComplexTypeRefNoMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-no-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, model)
}

// PutComplexTypeRefWithMeta - Puts a complex type that has a ref to a complex type with XML node
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutComplexTypeRefWithMetaOptions contains the optional parameters for the XMLClient.PutComplexTypeRefWithMeta
//     method.
func (client *XMLClient) PutComplexTypeRefWithMeta(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (result XMLClientPutComplexTypeRefWithMetaResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutComplexTypeRefWithMeta", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putComplexTypeRefWithMetaCreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putComplexTypeRefWithMetaCreateRequest creates the PutComplexTypeRefWithMeta request.
func (client *XMLClient) putComplexTypeRefWithMetaCreateRequest(ctx context.Context, model RootWithRefAndMeta, options *XMLClientPutComplexTypeRefWithMetaOptions) (*policy.Request, error) {
	urlPath := "/xml/complex-type-ref-with-meta"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, model)
}

// PutEmptyChildElement - Puts a value with an empty child element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyChildElementOptions contains the optional parameters for the XMLClient.PutEmptyChildElement
//     method.
func (client *XMLClient) PutEmptyChildElement(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (result XMLClientPutEmptyChildElementResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutEmptyChildElement", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putEmptyChildElementCreateRequest(ctx, banana, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putEmptyChildElementCreateRequest creates the PutEmptyChildElement request.
func (client *XMLClient) putEmptyChildElementCreateRequest(ctx context.Context, banana Banana, options *XMLClientPutEmptyChildElementOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-child-element"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, banana)
}

// PutEmptyList - Puts an empty list.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyListOptions contains the optional parameters for the XMLClient.PutEmptyList method.
func (client *XMLClient) PutEmptyList(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (result XMLClientPutEmptyListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutEmptyList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putEmptyListCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putEmptyListCreateRequest creates the PutEmptyList request.
func (client *XMLClient) putEmptyListCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutEmptyListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutEmptyRootList - Puts an empty list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyRootListOptions contains the optional parameters for the XMLClient.PutEmptyRootList method.
func (client *XMLClient) PutEmptyRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (result XMLClientPutEmptyRootListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutEmptyRootList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putEmptyRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putEmptyRootListCreateRequest creates the PutEmptyRootList request.
func (client *XMLClient) putEmptyRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutEmptyRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutEmptyWrappedLists - Puts some empty wrapped lists.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutEmptyWrappedListsOptions contains the optional parameters for the XMLClient.PutEmptyWrappedLists
//     method.
func (client *XMLClient) PutEmptyWrappedLists(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (result XMLClientPutEmptyWrappedListsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutEmptyWrappedLists", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putEmptyWrappedListsCreateRequest(ctx, appleBarrel, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putEmptyWrappedListsCreateRequest creates the PutEmptyWrappedLists request.
func (client *XMLClient) putEmptyWrappedListsCreateRequest(ctx context.Context, appleBarrel AppleBarrel, options *XMLClientPutEmptyWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/empty-wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	return req, runtime.MarshalAsXML(req, appleBarrel)
}

// PutRootList - Puts a list as the root element.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutRootListOptions contains the optional parameters for the XMLClient.PutRootList method.
func (client *XMLClient) PutRootList(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (result XMLClientPutRootListResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutRootList", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putRootListCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putRootListCreateRequest creates the PutRootList request.
func (client *XMLClient) putRootListCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutRootListSingleItem - Puts a list with a single item.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutRootListSingleItemOptions contains the optional parameters for the XMLClient.PutRootListSingleItem
//     method.
func (client *XMLClient) PutRootListSingleItem(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (result XMLClientPutRootListSingleItemResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutRootListSingleItem", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putRootListSingleItemCreateRequest(ctx, bananas, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putRootListSingleItemCreateRequest creates the PutRootListSingleItem request.
func (client *XMLClient) putRootListSingleItemCreateRequest(ctx context.Context, bananas []*Banana, options *XMLClientPutRootListSingleItemOptions) (*policy.Request, error) {
	urlPath := "/xml/root-list-single-item"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	type wrapper struct {
		XMLName xml.Name   `xml:"bananas"`
		Bananas *[]*Banana `xml:"banana"`
	}
	return req, runtime.MarshalAsXML(req, wrapper{Bananas: &bananas})
}

// PutServiceProperties - Puts storage service properties.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutServicePropertiesOptions contains the optional parameters for the XMLClient.PutServiceProperties
//     method.
func (client *XMLClient) PutServiceProperties(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (result XMLClientPutServicePropertiesResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutServiceProperties", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putServicePropertiesCreateRequest(ctx, properties, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putServicePropertiesCreateRequest creates the PutServiceProperties request.
func (client *XMLClient) putServicePropertiesCreateRequest(ctx context.Context, properties StorageServiceProperties, options *XMLClientPutServicePropertiesOptions) (*policy.Request, error) {
	urlPath := "/xml/"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	reqQP.Set("restype", "service")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsXML(req, properties)
}

// PutSimple - Put a simple XML document
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutSimpleOptions contains the optional parameters for the XMLClient.PutSimple method.
func (client *XMLClient) PutSimple(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (result XMLClientPutSimpleResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutSimple", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putSimpleCreateRequest(ctx, slideshow, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putSimpleCreateRequest creates the PutSimple request.
func (client *XMLClient) putSimpleCreateRequest(ctx context.Context, slideshow Slideshow, options *XMLClientPutSimpleOptions) (*policy.Request, error) {
	urlPath := "/xml/simple"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, slideshow)
}

// PutURI - Put an XML document with uri property
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutURIOptions contains the optional parameters for the XMLClient.PutURI method.
func (client *XMLClient) PutURI(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (result XMLClientPutURIResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutURI", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putURICreateRequest(ctx, model, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putURICreateRequest creates the PutURI request.
func (client *XMLClient) putURICreateRequest(ctx context.Context, model ModelWithURLProperty, options *XMLClientPutURIOptions) (*policy.Request, error) {
	urlPath := "/xml/url"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, model)
}

// PutWrappedLists - Put an XML document with multiple wrapped lists
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - XMLClientPutWrappedListsOptions contains the optional parameters for the XMLClient.PutWrappedLists method.
func (client *XMLClient) PutWrappedLists(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (result XMLClientPutWrappedListsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "XMLClient.PutWrappedLists", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putWrappedListsCreateRequest(ctx, wrappedLists, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putWrappedListsCreateRequest creates the PutWrappedLists request.
func (client *XMLClient) putWrappedListsCreateRequest(ctx context.Context, wrappedLists AppleBarrel, options *XMLClientPutWrappedListsOptions) (*policy.Request, error) {
	urlPath := "/xml/wrapped-lists"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsXML(req, wrappedLists)
}
