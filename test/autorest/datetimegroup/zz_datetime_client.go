//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package datetimegroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
	"time"
)

// DatetimeClient contains the methods for the Datetime group.
// Don't use this type directly, use a constructor function instead.
type DatetimeClient struct {
	internal *azcore.Client
}

// GetInvalid - Get invalid datetime value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetInvalidOptions contains the optional parameters for the DatetimeClient.GetInvalid method.
func (client *DatetimeClient) GetInvalid(ctx context.Context, options *DatetimeClientGetInvalidOptions) (result DatetimeClientGetInvalidResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetInvalid", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getInvalidCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getInvalidHandleResponse(resp)
	return
}

// getInvalidCreateRequest creates the GetInvalid request.
func (client *DatetimeClient) getInvalidCreateRequest(ctx context.Context, options *DatetimeClientGetInvalidOptions) (*policy.Request, error) {
	urlPath := "/datetime/invalid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInvalidHandleResponse handles the GetInvalid response.
func (client *DatetimeClient) getInvalidHandleResponse(resp *http.Response) (result DatetimeClientGetInvalidResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetLowercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetLocalNegativeOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (result DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalNegativeOffsetLowercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp)
	return
}

// getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetLowercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalNegativeOffsetLowercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetMinDateTime
//     method.
func (client *DatetimeClient) GetLocalNegativeOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions) (result DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalNegativeOffsetMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalNegativeOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalNegativeOffsetMinDateTimeHandleResponse(resp)
	return
}

// getLocalNegativeOffsetMinDateTimeCreateRequest creates the GetLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetMinDateTimeHandleResponse handles the GetLocalNegativeOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetMinDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalNegativeOffsetMinDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNegativeOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNegativeOffsetUppercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetLocalNegativeOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (result DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalNegativeOffsetUppercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp)
	return
}

// getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalNegativeOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalNegativeOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalNegativeOffsetUppercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalNegativeOffsetUppercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalNoOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalNoOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalNoOffsetMinDateTime
//     method.
func (client *DatetimeClient) GetLocalNoOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalNoOffsetMinDateTimeOptions) (result DatetimeClientGetLocalNoOffsetMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalNoOffsetMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalNoOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalNoOffsetMinDateTimeHandleResponse(resp)
	return
}

// getLocalNoOffsetMinDateTimeCreateRequest creates the GetLocalNoOffsetMinDateTime request.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalNoOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnooffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalNoOffsetMinDateTimeHandleResponse handles the GetLocalNoOffsetMinDateTime response.
func (client *DatetimeClient) getLocalNoOffsetMinDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalNoOffsetMinDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetLowercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetLowercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetLocalPositiveOffsetLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (result DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalPositiveOffsetLowercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp)
	return
}

// getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetLowercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetLowercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetLowercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalPositiveOffsetLowercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetMinDateTime - Get min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetMinDateTime
//     method.
func (client *DatetimeClient) GetLocalPositiveOffsetMinDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions) (result DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalPositiveOffsetMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalPositiveOffsetMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalPositiveOffsetMinDateTimeHandleResponse(resp)
	return
}

// getLocalPositiveOffsetMinDateTimeCreateRequest creates the GetLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetMinDateTimeHandleResponse handles the GetLocalPositiveOffsetMinDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetMinDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalPositiveOffsetMinDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetLocalPositiveOffsetUppercaseMaxDateTime - Get max datetime value with positive num offset 9999-12-31T23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetLocalPositiveOffsetUppercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetLocalPositiveOffsetUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (result DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetLocalPositiveOffsetUppercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp)
	return
}

// getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest creates the GetLocalPositiveOffsetUppercaseMaxDateTime request.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse handles the GetLocalPositiveOffsetUppercaseMaxDateTime response.
func (client *DatetimeClient) getLocalPositiveOffsetUppercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetLocalPositiveOffsetUppercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetNull - Get null datetime value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetNullOptions contains the optional parameters for the DatetimeClient.GetNull method.
func (client *DatetimeClient) GetNull(ctx context.Context, options *DatetimeClientGetNullOptions) (result DatetimeClientGetNullResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetNull", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getNullCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getNullHandleResponse(resp)
	return
}

// getNullCreateRequest creates the GetNull request.
func (client *DatetimeClient) getNullCreateRequest(ctx context.Context, options *DatetimeClientGetNullOptions) (*policy.Request, error) {
	urlPath := "/datetime/null"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getNullHandleResponse handles the GetNull response.
func (client *DatetimeClient) getNullHandleResponse(resp *http.Response) (result DatetimeClientGetNullResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetOverflow - Get overflow datetime value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetOverflowOptions contains the optional parameters for the DatetimeClient.GetOverflow method.
func (client *DatetimeClient) GetOverflow(ctx context.Context, options *DatetimeClientGetOverflowOptions) (result DatetimeClientGetOverflowResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetOverflow", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getOverflowCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getOverflowHandleResponse(resp)
	return
}

// getOverflowCreateRequest creates the GetOverflow request.
func (client *DatetimeClient) getOverflowCreateRequest(ctx context.Context, options *DatetimeClientGetOverflowOptions) (*policy.Request, error) {
	urlPath := "/datetime/overflow"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getOverflowHandleResponse handles the GetOverflow response.
func (client *DatetimeClient) getOverflowHandleResponse(resp *http.Response) (result DatetimeClientGetOverflowResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCLowercaseMaxDateTime - Get max datetime value 9999-12-31t23:59:59.999z
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetUTCLowercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCLowercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetUTCLowercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetUTCLowercaseMaxDateTimeOptions) (result DatetimeClientGetUTCLowercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetUTCLowercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getUTCLowercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getUTCLowercaseMaxDateTimeHandleResponse(resp)
	return
}

// getUTCLowercaseMaxDateTimeCreateRequest creates the GetUTCLowercaseMaxDateTime request.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCLowercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc/lowercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCLowercaseMaxDateTimeHandleResponse handles the GetUTCLowercaseMaxDateTime response.
func (client *DatetimeClient) getUTCLowercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetUTCLowercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCMinDateTime - Get min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetUTCMinDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCMinDateTime
//     method.
func (client *DatetimeClient) GetUTCMinDateTime(ctx context.Context, options *DatetimeClientGetUTCMinDateTimeOptions) (result DatetimeClientGetUTCMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetUTCMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getUTCMinDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getUTCMinDateTimeHandleResponse(resp)
	return
}

// getUTCMinDateTimeCreateRequest creates the GetUTCMinDateTime request.
func (client *DatetimeClient) getUTCMinDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCMinDateTimeHandleResponse handles the GetUTCMinDateTime response.
func (client *DatetimeClient) getUTCMinDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetUTCMinDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCUppercaseMaxDateTime - Get max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetUTCUppercaseMaxDateTimeOptions contains the optional parameters for the DatetimeClient.GetUTCUppercaseMaxDateTime
//     method.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTimeOptions) (result DatetimeClientGetUTCUppercaseMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetUTCUppercaseMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getUTCUppercaseMaxDateTimeCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getUTCUppercaseMaxDateTimeHandleResponse(resp)
	return
}

// getUTCUppercaseMaxDateTimeCreateRequest creates the GetUTCUppercaseMaxDateTime request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeCreateRequest(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCUppercaseMaxDateTimeHandleResponse handles the GetUTCUppercaseMaxDateTime response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTimeHandleResponse(resp *http.Response) (result DatetimeClientGetUTCUppercaseMaxDateTimeResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUTCUppercaseMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens
// in that scenario
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions contains the optional parameters for the DatetimeClient.GetUTCUppercaseMaxDateTime7Digits
//     method.
func (client *DatetimeClient) GetUTCUppercaseMaxDateTime7Digits(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions) (result DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetUTCUppercaseMaxDateTime7Digits", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp)
	return
}

// getUTCUppercaseMaxDateTime7DigitsCreateRequest creates the GetUTCUppercaseMaxDateTime7Digits request.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsCreateRequest(ctx context.Context, options *DatetimeClientGetUTCUppercaseMaxDateTime7DigitsOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc7ms/uppercase"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUTCUppercaseMaxDateTime7DigitsHandleResponse handles the GetUTCUppercaseMaxDateTime7Digits response.
func (client *DatetimeClient) getUTCUppercaseMaxDateTime7DigitsHandleResponse(resp *http.Response) (result DatetimeClientGetUTCUppercaseMaxDateTime7DigitsResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// GetUnderflow - Get underflow datetime value
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - DatetimeClientGetUnderflowOptions contains the optional parameters for the DatetimeClient.GetUnderflow method.
func (client *DatetimeClient) GetUnderflow(ctx context.Context, options *DatetimeClientGetUnderflowOptions) (result DatetimeClientGetUnderflowResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.GetUnderflow", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getUnderflowCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getUnderflowHandleResponse(resp)
	return
}

// getUnderflowCreateRequest creates the GetUnderflow request.
func (client *DatetimeClient) getUnderflowCreateRequest(ctx context.Context, options *DatetimeClientGetUnderflowOptions) (*policy.Request, error) {
	urlPath := "/datetime/underflow"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getUnderflowHandleResponse handles the GetUnderflow response.
func (client *DatetimeClient) getUnderflowHandleResponse(resp *http.Response) (result DatetimeClientGetUnderflowResponse, err error) {
	var aux *timeRFC3339
	if err = runtime.UnmarshalAsJSON(resp, &aux); err != nil {
		return
	}
	result.Value = (*time.Time)(aux)
	return result, nil
}

// PutLocalNegativeOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999-14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalNegativeOffsetMaxDateTime
//     method.
func (client *DatetimeClient) PutLocalNegativeOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions) (result DatetimeClientPutLocalNegativeOffsetMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutLocalNegativeOffsetMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putLocalNegativeOffsetMaxDateTimeCreateRequest creates the PutLocalNegativeOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalNegativeOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00-14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalNegativeOffsetMinDateTime
//     method.
func (client *DatetimeClient) PutLocalNegativeOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions) (result DatetimeClientPutLocalNegativeOffsetMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutLocalNegativeOffsetMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putLocalNegativeOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putLocalNegativeOffsetMinDateTimeCreateRequest creates the PutLocalNegativeOffsetMinDateTime request.
func (client *DatetimeClient) putLocalNegativeOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalNegativeOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localnegativeoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalPositiveOffsetMaxDateTime - Put max datetime value with positive numoffset 9999-12-31t23:59:59.999+14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalPositiveOffsetMaxDateTime
//     method.
func (client *DatetimeClient) PutLocalPositiveOffsetMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions) (result DatetimeClientPutLocalPositiveOffsetMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutLocalPositiveOffsetMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putLocalPositiveOffsetMaxDateTimeCreateRequest creates the PutLocalPositiveOffsetMaxDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutLocalPositiveOffsetMinDateTime - Put min datetime value 0001-01-01T00:00:00+14:00
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutLocalPositiveOffsetMinDateTime
//     method.
func (client *DatetimeClient) PutLocalPositiveOffsetMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions) (result DatetimeClientPutLocalPositiveOffsetMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutLocalPositiveOffsetMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putLocalPositiveOffsetMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putLocalPositiveOffsetMinDateTimeCreateRequest creates the PutLocalPositiveOffsetMinDateTime request.
func (client *DatetimeClient) putLocalPositiveOffsetMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutLocalPositiveOffsetMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/localpositiveoffset"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMaxDateTime - Put max datetime value 9999-12-31T23:59:59.999Z
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutUTCMaxDateTimeOptions contains the optional parameters for the DatetimeClient.PutUTCMaxDateTime
//     method.
func (client *DatetimeClient) PutUTCMaxDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTimeOptions) (result DatetimeClientPutUTCMaxDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutUTCMaxDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putUTCMaxDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putUTCMaxDateTimeCreateRequest creates the PutUTCMaxDateTime request.
func (client *DatetimeClient) putUTCMaxDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMaxDateTime7Digits - This is against the recommendation that asks for 3 digits, but allow to test what happens in
// that scenario
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutUTCMaxDateTime7DigitsOptions contains the optional parameters for the DatetimeClient.PutUTCMaxDateTime7Digits
//     method.
func (client *DatetimeClient) PutUTCMaxDateTime7Digits(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTime7DigitsOptions) (result DatetimeClientPutUTCMaxDateTime7DigitsResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutUTCMaxDateTime7Digits", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putUTCMaxDateTime7DigitsCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putUTCMaxDateTime7DigitsCreateRequest creates the PutUTCMaxDateTime7Digits request.
func (client *DatetimeClient) putUTCMaxDateTime7DigitsCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMaxDateTime7DigitsOptions) (*policy.Request, error) {
	urlPath := "/datetime/max/utc7ms"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}

// PutUTCMinDateTime - Put min datetime value 0001-01-01T00:00:00Z
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - datetimeBody - datetime body
//   - options - DatetimeClientPutUTCMinDateTimeOptions contains the optional parameters for the DatetimeClient.PutUTCMinDateTime
//     method.
func (client *DatetimeClient) PutUTCMinDateTime(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMinDateTimeOptions) (result DatetimeClientPutUTCMinDateTimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "DatetimeClient.PutUTCMinDateTime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putUTCMinDateTimeCreateRequest(ctx, datetimeBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putUTCMinDateTimeCreateRequest creates the PutUTCMinDateTime request.
func (client *DatetimeClient) putUTCMinDateTimeCreateRequest(ctx context.Context, datetimeBody time.Time, options *DatetimeClientPutUTCMinDateTimeOptions) (*policy.Request, error) {
	urlPath := "/datetime/min/utc"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, datetimeBody)
}
