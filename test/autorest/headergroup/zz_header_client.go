//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package headergroup

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
	"strconv"
	"time"
)

// HeaderClient contains the methods for the Header group.
// Don't use this type directly, use a constructor function instead.
type HeaderClient struct {
	internal *azcore.Client
}

// CustomRequestID - Send x-ms-client-request-id = 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0 in the header of the request
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientCustomRequestIDOptions contains the optional parameters for the HeaderClient.CustomRequestID method.
func (client *HeaderClient) CustomRequestID(ctx context.Context, options *HeaderClientCustomRequestIDOptions) (result HeaderClientCustomRequestIDResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.CustomRequestID", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.customRequestIDCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// customRequestIDCreateRequest creates the CustomRequestID request.
func (client *HeaderClient) customRequestIDCreateRequest(ctx context.Context, options *HeaderClientCustomRequestIDOptions) (*policy.Request, error) {
	urlPath := "/header/custom/x-ms-client-request-id/9C4D50EE-2D56-4CD3-8152-34347DC9F2B0"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamBool - Send a post request with header values "scenario": "true", "value": true or "scenario": "false", "value": false
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "true" or "false"
//   - value - Send a post request with header values true or false
//   - options - HeaderClientParamBoolOptions contains the optional parameters for the HeaderClient.ParamBool method.
func (client *HeaderClient) ParamBool(ctx context.Context, scenario string, value bool, options *HeaderClientParamBoolOptions) (result HeaderClientParamBoolResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamBool", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramBoolCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramBoolCreateRequest creates the ParamBool request.
func (client *HeaderClient) paramBoolCreateRequest(ctx context.Context, scenario string, value bool, options *HeaderClientParamBoolOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/bool"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatBool(value)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamByte - Send a post request with header values "scenario": "valid", "value": "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - value - Send a post request with header values "啊齄丂狛狜隣郎隣兀﨩"
//   - options - HeaderClientParamByteOptions contains the optional parameters for the HeaderClient.ParamByte method.
func (client *HeaderClient) ParamByte(ctx context.Context, scenario string, value []byte, options *HeaderClientParamByteOptions) (result HeaderClientParamByteResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamByte", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramByteCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramByteCreateRequest creates the ParamByte request.
func (client *HeaderClient) paramByteCreateRequest(ctx context.Context, scenario string, value []byte, options *HeaderClientParamByteOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/byte"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{base64.StdEncoding.EncodeToString(value)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamDate - Send a post request with header values "scenario": "valid", "value": "2010-01-01" or "scenario": "min", "value":
// "0001-01-01"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - value - Send a post request with header values "2010-01-01" or "0001-01-01"
//   - options - HeaderClientParamDateOptions contains the optional parameters for the HeaderClient.ParamDate method.
func (client *HeaderClient) ParamDate(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDateOptions) (result HeaderClientParamDateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamDate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramDateCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramDateCreateRequest creates the ParamDate request.
func (client *HeaderClient) paramDateCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDateOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/date"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value.Format("2006-01-02")}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamDatetime - Send a post request with header values "scenario": "valid", "value": "2010-01-01T12:34:56Z" or "scenario":
// "min", "value": "0001-01-01T00:00:00Z"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - value - Send a post request with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
//   - options - HeaderClientParamDatetimeOptions contains the optional parameters for the HeaderClient.ParamDatetime method.
func (client *HeaderClient) ParamDatetime(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDatetimeOptions) (result HeaderClientParamDatetimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamDatetime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramDatetimeCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramDatetimeCreateRequest creates the ParamDatetime request.
func (client *HeaderClient) paramDatetimeCreateRequest(ctx context.Context, scenario string, value time.Time, options *HeaderClientParamDatetimeOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value.Format(time.RFC3339Nano)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamDatetimeRFC1123 - Send a post request with header values "scenario": "valid", "value": "Wed, 01 Jan 2010 12:34:56
// GMT" or "scenario": "min", "value": "Mon, 01 Jan 0001 00:00:00 GMT"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientParamDatetimeRFC1123Options contains the optional parameters for the HeaderClient.ParamDatetimeRFC1123
//     method.
func (client *HeaderClient) ParamDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderClientParamDatetimeRFC1123Options) (result HeaderClientParamDatetimeRFC1123Response, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamDatetimeRFC1123", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramDatetimeRFC1123CreateRequest creates the ParamDatetimeRFC1123 request.
func (client *HeaderClient) paramDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderClientParamDatetimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/header/param/prim/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{options.Value.Format(time.RFC1123)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamDouble - Send a post request with header values "scenario": "positive", "value": 7e120 or "scenario": "negative",
// "value": -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 7e120 or -3.0
//   - options - HeaderClientParamDoubleOptions contains the optional parameters for the HeaderClient.ParamDouble method.
func (client *HeaderClient) ParamDouble(ctx context.Context, scenario string, value float64, options *HeaderClientParamDoubleOptions) (result HeaderClientParamDoubleResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamDouble", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramDoubleCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramDoubleCreateRequest creates the ParamDouble request.
func (client *HeaderClient) paramDoubleCreateRequest(ctx context.Context, scenario string, value float64, options *HeaderClientParamDoubleOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/double"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatFloat(value, 'f', -1, 64)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamDuration - Send a post request with header values "scenario": "valid", "value": "P123DT22H14M12.011S"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - value - Send a post request with header values "P123DT22H14M12.011S"
//   - options - HeaderClientParamDurationOptions contains the optional parameters for the HeaderClient.ParamDuration method.
func (client *HeaderClient) ParamDuration(ctx context.Context, scenario string, value string, options *HeaderClientParamDurationOptions) (result HeaderClientParamDurationResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamDuration", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramDurationCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramDurationCreateRequest creates the ParamDuration request.
func (client *HeaderClient) paramDurationCreateRequest(ctx context.Context, scenario string, value string, options *HeaderClientParamDurationOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/duration"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{value}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamEnum - Send a post request with header values "scenario": "valid", "value": "GREY" or "scenario": "null", "value":
// null
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientParamEnumOptions contains the optional parameters for the HeaderClient.ParamEnum method.
func (client *HeaderClient) ParamEnum(ctx context.Context, scenario string, options *HeaderClientParamEnumOptions) (result HeaderClientParamEnumResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamEnum", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramEnumCreateRequest creates the ParamEnum request.
func (client *HeaderClient) paramEnumCreateRequest(ctx context.Context, scenario string, options *HeaderClientParamEnumOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/enum"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{string(*options.Value)}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamExistingKey - Send a post request with header value "User-Agent": "overwrite"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - userAgent - Send a post request with header value "User-Agent": "overwrite"
//   - options - HeaderClientParamExistingKeyOptions contains the optional parameters for the HeaderClient.ParamExistingKey method.
func (client *HeaderClient) ParamExistingKey(ctx context.Context, userAgent string, options *HeaderClientParamExistingKeyOptions) (result HeaderClientParamExistingKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamExistingKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramExistingKeyCreateRequest(ctx, userAgent, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramExistingKeyCreateRequest creates the ParamExistingKey request.
func (client *HeaderClient) paramExistingKeyCreateRequest(ctx context.Context, userAgent string, options *HeaderClientParamExistingKeyOptions) (*policy.Request, error) {
	urlPath := "/header/param/existingkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["User-Agent"] = []string{userAgent}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamFloat - Send a post request with header values "scenario": "positive", "value": 0.07 or "scenario": "negative", "value":
// -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 0.07 or -3.0
//   - options - HeaderClientParamFloatOptions contains the optional parameters for the HeaderClient.ParamFloat method.
func (client *HeaderClient) ParamFloat(ctx context.Context, scenario string, value float32, options *HeaderClientParamFloatOptions) (result HeaderClientParamFloatResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamFloat", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramFloatCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramFloatCreateRequest creates the ParamFloat request.
func (client *HeaderClient) paramFloatCreateRequest(ctx context.Context, scenario string, value float32, options *HeaderClientParamFloatOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/float"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatFloat(float64(value), 'f', -1, 32)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamInteger - Send a post request with header values "scenario": "positive", "value": 1 or "scenario": "negative", "value":
// -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 1 or -2
//   - options - HeaderClientParamIntegerOptions contains the optional parameters for the HeaderClient.ParamInteger method.
func (client *HeaderClient) ParamInteger(ctx context.Context, scenario string, value int32, options *HeaderClientParamIntegerOptions) (result HeaderClientParamIntegerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamInteger", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramIntegerCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramIntegerCreateRequest creates the ParamInteger request.
func (client *HeaderClient) paramIntegerCreateRequest(ctx context.Context, scenario string, value int32, options *HeaderClientParamIntegerOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/integer"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatInt(int64(value), 10)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamLong - Send a post request with header values "scenario": "positive", "value": 105 or "scenario": "negative", "value":
// -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - value - Send a post request with header values 105 or -2
//   - options - HeaderClientParamLongOptions contains the optional parameters for the HeaderClient.ParamLong method.
func (client *HeaderClient) ParamLong(ctx context.Context, scenario string, value int64, options *HeaderClientParamLongOptions) (result HeaderClientParamLongResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamLong", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramLongCreateRequest(ctx, scenario, value, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramLongCreateRequest creates the ParamLong request.
func (client *HeaderClient) paramLongCreateRequest(ctx context.Context, scenario string, value int64, options *HeaderClientParamLongOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/long"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["value"] = []string{strconv.FormatInt(value, 10)}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamProtectedKey - Send a post request with header value "Content-Type": "text/html"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - contentType - Send a post request with header value "Content-Type": "text/html"
//   - options - HeaderClientParamProtectedKeyOptions contains the optional parameters for the HeaderClient.ParamProtectedKey
//     method.
func (client *HeaderClient) ParamProtectedKey(ctx context.Context, contentType string, options *HeaderClientParamProtectedKeyOptions) (result HeaderClientParamProtectedKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamProtectedKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramProtectedKeyCreateRequest(ctx, contentType, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramProtectedKeyCreateRequest creates the ParamProtectedKey request.
func (client *HeaderClient) paramProtectedKeyCreateRequest(ctx context.Context, contentType string, options *HeaderClientParamProtectedKeyOptions) (*policy.Request, error) {
	urlPath := "/header/param/protectedkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Content-Type"] = []string{contentType}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ParamString - Send a post request with header values "scenario": "valid", "value": "The quick brown fox jumps over the
// lazy dog" or "scenario": "null", "value": null or "scenario": "empty", "value": ""
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientParamStringOptions contains the optional parameters for the HeaderClient.ParamString method.
func (client *HeaderClient) ParamString(ctx context.Context, scenario string, options *HeaderClientParamStringOptions) (result HeaderClientParamStringResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ParamString", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.paramStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// paramStringCreateRequest creates the ParamString request.
func (client *HeaderClient) paramStringCreateRequest(ctx context.Context, scenario string, options *HeaderClientParamStringOptions) (*policy.Request, error) {
	urlPath := "/header/param/prim/string"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	if options != nil && options.Value != nil {
		req.Raw().Header["value"] = []string{*options.Value}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// ResponseBool - Get a response with header value "value": true or false
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "true" or "false"
//   - options - HeaderClientResponseBoolOptions contains the optional parameters for the HeaderClient.ResponseBool method.
func (client *HeaderClient) ResponseBool(ctx context.Context, scenario string, options *HeaderClientResponseBoolOptions) (result HeaderClientResponseBoolResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseBool", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseBoolCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseBoolHandleResponse(resp)
	return
}

// responseBoolCreateRequest creates the ResponseBool request.
func (client *HeaderClient) responseBoolCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseBoolOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/bool"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseBoolHandleResponse handles the ResponseBool response.
func (client *HeaderClient) responseBoolHandleResponse(resp *http.Response) (result HeaderClientResponseBoolResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseBool(val)
		if err != nil {
			return HeaderClientResponseBoolResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseByte - Get a response with header values "啊齄丂狛狜隣郎隣兀﨩"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - options - HeaderClientResponseByteOptions contains the optional parameters for the HeaderClient.ResponseByte method.
func (client *HeaderClient) ResponseByte(ctx context.Context, scenario string, options *HeaderClientResponseByteOptions) (result HeaderClientResponseByteResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseByte", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseByteCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseByteHandleResponse(resp)
	return
}

// responseByteCreateRequest creates the ResponseByte request.
func (client *HeaderClient) responseByteCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseByteOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/byte"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseByteHandleResponse handles the ResponseByte response.
func (client *HeaderClient) responseByteHandleResponse(resp *http.Response) (result HeaderClientResponseByteResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return HeaderClientResponseByteResponse{}, err
		}
		result.Value = value
	}
	return result, nil
}

// ResponseDate - Get a response with header values "2010-01-01" or "0001-01-01"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDateOptions contains the optional parameters for the HeaderClient.ResponseDate method.
func (client *HeaderClient) ResponseDate(ctx context.Context, scenario string, options *HeaderClientResponseDateOptions) (result HeaderClientResponseDateResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseDate", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseDateCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseDateHandleResponse(resp)
	return
}

// responseDateCreateRequest creates the ResponseDate request.
func (client *HeaderClient) responseDateCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDateOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/date"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseDateHandleResponse handles the ResponseDate response.
func (client *HeaderClient) responseDateHandleResponse(resp *http.Response) (result HeaderClientResponseDateResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse("2006-01-02", val)
		if err != nil {
			return HeaderClientResponseDateResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDatetime - Get a response with header values "2010-01-01T12:34:56Z" or "0001-01-01T00:00:00Z"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDatetimeOptions contains the optional parameters for the HeaderClient.ResponseDatetime method.
func (client *HeaderClient) ResponseDatetime(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeOptions) (result HeaderClientResponseDatetimeResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseDatetime", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseDatetimeCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseDatetimeHandleResponse(resp)
	return
}

// responseDatetimeCreateRequest creates the ResponseDatetime request.
func (client *HeaderClient) responseDatetimeCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/datetime"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseDatetimeHandleResponse handles the ResponseDatetime response.
func (client *HeaderClient) responseDatetimeHandleResponse(resp *http.Response) (result HeaderClientResponseDatetimeResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC3339Nano, val)
		if err != nil {
			return HeaderClientResponseDatetimeResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDatetimeRFC1123 - Get a response with header values "Wed, 01 Jan 2010 12:34:56 GMT" or "Mon, 01 Jan 0001 00:00:00
// GMT"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "min"
//   - options - HeaderClientResponseDatetimeRFC1123Options contains the optional parameters for the HeaderClient.ResponseDatetimeRFC1123
//     method.
func (client *HeaderClient) ResponseDatetimeRFC1123(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeRFC1123Options) (result HeaderClientResponseDatetimeRFC1123Response, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseDatetimeRFC1123", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseDatetimeRFC1123CreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseDatetimeRFC1123HandleResponse(resp)
	return
}

// responseDatetimeRFC1123CreateRequest creates the ResponseDatetimeRFC1123 request.
func (client *HeaderClient) responseDatetimeRFC1123CreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDatetimeRFC1123Options) (*policy.Request, error) {
	urlPath := "/header/response/prim/datetimerfc1123"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseDatetimeRFC1123HandleResponse handles the ResponseDatetimeRFC1123 response.
func (client *HeaderClient) responseDatetimeRFC1123HandleResponse(resp *http.Response) (result HeaderClientResponseDatetimeRFC1123Response, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return HeaderClientResponseDatetimeRFC1123Response{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDouble - Get a response with header value "value": 7e120 or -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseDoubleOptions contains the optional parameters for the HeaderClient.ResponseDouble method.
func (client *HeaderClient) ResponseDouble(ctx context.Context, scenario string, options *HeaderClientResponseDoubleOptions) (result HeaderClientResponseDoubleResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseDouble", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseDoubleCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseDoubleHandleResponse(resp)
	return
}

// responseDoubleCreateRequest creates the ResponseDouble request.
func (client *HeaderClient) responseDoubleCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDoubleOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/double"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseDoubleHandleResponse handles the ResponseDouble response.
func (client *HeaderClient) responseDoubleHandleResponse(resp *http.Response) (result HeaderClientResponseDoubleResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseFloat(val, 64)
		if err != nil {
			return HeaderClientResponseDoubleResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseDuration - Get a response with header values "P123DT22H14M12.011S"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid"
//   - options - HeaderClientResponseDurationOptions contains the optional parameters for the HeaderClient.ResponseDuration method.
func (client *HeaderClient) ResponseDuration(ctx context.Context, scenario string, options *HeaderClientResponseDurationOptions) (result HeaderClientResponseDurationResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseDuration", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseDurationCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseDurationHandleResponse(resp)
	return
}

// responseDurationCreateRequest creates the ResponseDuration request.
func (client *HeaderClient) responseDurationCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseDurationOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/duration"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseDurationHandleResponse handles the ResponseDuration response.
func (client *HeaderClient) responseDurationHandleResponse(resp *http.Response) (result HeaderClientResponseDurationResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}

// ResponseEnum - Get a response with header values "GREY" or null
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientResponseEnumOptions contains the optional parameters for the HeaderClient.ResponseEnum method.
func (client *HeaderClient) ResponseEnum(ctx context.Context, scenario string, options *HeaderClientResponseEnumOptions) (result HeaderClientResponseEnumResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseEnum", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseEnumCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseEnumHandleResponse(resp)
	return
}

// responseEnumCreateRequest creates the ResponseEnum request.
func (client *HeaderClient) responseEnumCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseEnumOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/enum"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseEnumHandleResponse handles the ResponseEnum response.
func (client *HeaderClient) responseEnumHandleResponse(resp *http.Response) (result HeaderClientResponseEnumResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		result.Value = (*GreyscaleColors)(&val)
	}
	return result, nil
}

// ResponseExistingKey - Get a response with header value "User-Agent": "overwrite"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientResponseExistingKeyOptions contains the optional parameters for the HeaderClient.ResponseExistingKey
//     method.
func (client *HeaderClient) ResponseExistingKey(ctx context.Context, options *HeaderClientResponseExistingKeyOptions) (result HeaderClientResponseExistingKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseExistingKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseExistingKeyCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseExistingKeyHandleResponse(resp)
	return
}

// responseExistingKeyCreateRequest creates the ResponseExistingKey request.
func (client *HeaderClient) responseExistingKeyCreateRequest(ctx context.Context, options *HeaderClientResponseExistingKeyOptions) (*policy.Request, error) {
	urlPath := "/header/response/existingkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseExistingKeyHandleResponse handles the ResponseExistingKey response.
func (client *HeaderClient) responseExistingKeyHandleResponse(resp *http.Response) (result HeaderClientResponseExistingKeyResponse, err error) {
	if val := resp.Header.Get("User-Agent"); val != "" {
		result.UserAgent = &val
	}
	return result, nil
}

// ResponseFloat - Get a response with header value "value": 0.07 or -3.0
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseFloatOptions contains the optional parameters for the HeaderClient.ResponseFloat method.
func (client *HeaderClient) ResponseFloat(ctx context.Context, scenario string, options *HeaderClientResponseFloatOptions) (result HeaderClientResponseFloatResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseFloat", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseFloatCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseFloatHandleResponse(resp)
	return
}

// responseFloatCreateRequest creates the ResponseFloat request.
func (client *HeaderClient) responseFloatCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseFloatOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/float"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseFloatHandleResponse handles the ResponseFloat response.
func (client *HeaderClient) responseFloatHandleResponse(resp *http.Response) (result HeaderClientResponseFloatResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseFloat(val, 32)
		value := float32(value32)
		if err != nil {
			return HeaderClientResponseFloatResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseInteger - Get a response with header value "value": 1 or -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseIntegerOptions contains the optional parameters for the HeaderClient.ResponseInteger method.
func (client *HeaderClient) ResponseInteger(ctx context.Context, scenario string, options *HeaderClientResponseIntegerOptions) (result HeaderClientResponseIntegerResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseInteger", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseIntegerCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseIntegerHandleResponse(resp)
	return
}

// responseIntegerCreateRequest creates the ResponseInteger request.
func (client *HeaderClient) responseIntegerCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseIntegerOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/integer"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseIntegerHandleResponse handles the ResponseInteger response.
func (client *HeaderClient) responseIntegerHandleResponse(resp *http.Response) (result HeaderClientResponseIntegerResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value32, err := strconv.ParseInt(val, 10, 32)
		value := int32(value32)
		if err != nil {
			return HeaderClientResponseIntegerResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseLong - Get a response with header value "value": 105 or -2
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "positive" or "negative"
//   - options - HeaderClientResponseLongOptions contains the optional parameters for the HeaderClient.ResponseLong method.
func (client *HeaderClient) ResponseLong(ctx context.Context, scenario string, options *HeaderClientResponseLongOptions) (result HeaderClientResponseLongResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseLong", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseLongCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseLongHandleResponse(resp)
	return
}

// responseLongCreateRequest creates the ResponseLong request.
func (client *HeaderClient) responseLongCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseLongOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/long"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseLongHandleResponse handles the ResponseLong response.
func (client *HeaderClient) responseLongHandleResponse(resp *http.Response) (result HeaderClientResponseLongResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		value, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return HeaderClientResponseLongResponse{}, err
		}
		result.Value = &value
	}
	return result, nil
}

// ResponseProtectedKey - Get a response with header value "Content-Type": "text/html"
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - options - HeaderClientResponseProtectedKeyOptions contains the optional parameters for the HeaderClient.ResponseProtectedKey
//     method.
func (client *HeaderClient) ResponseProtectedKey(ctx context.Context, options *HeaderClientResponseProtectedKeyOptions) (result HeaderClientResponseProtectedKeyResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseProtectedKey", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseProtectedKeyCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseProtectedKeyHandleResponse(resp)
	return
}

// responseProtectedKeyCreateRequest creates the ResponseProtectedKey request.
func (client *HeaderClient) responseProtectedKeyCreateRequest(ctx context.Context, options *HeaderClientResponseProtectedKeyOptions) (*policy.Request, error) {
	urlPath := "/header/response/protectedkey"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseProtectedKeyHandleResponse handles the ResponseProtectedKey response.
func (client *HeaderClient) responseProtectedKeyHandleResponse(resp *http.Response) (result HeaderClientResponseProtectedKeyResponse, err error) {
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// ResponseString - Get a response with header values "The quick brown fox jumps over the lazy dog" or null or ""
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 1.0.0
//   - scenario - Send a post request with header values "scenario": "valid" or "null" or "empty"
//   - options - HeaderClientResponseStringOptions contains the optional parameters for the HeaderClient.ResponseString method.
func (client *HeaderClient) ResponseString(ctx context.Context, scenario string, options *HeaderClientResponseStringOptions) (result HeaderClientResponseStringResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "HeaderClient.ResponseString", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.responseStringCreateRequest(ctx, scenario, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.responseStringHandleResponse(resp)
	return
}

// responseStringCreateRequest creates the ResponseString request.
func (client *HeaderClient) responseStringCreateRequest(ctx context.Context, scenario string, options *HeaderClientResponseStringOptions) (*policy.Request, error) {
	urlPath := "/header/response/prim/string"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["scenario"] = []string{scenario}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// responseStringHandleResponse handles the ResponseString response.
func (client *HeaderClient) responseStringHandleResponse(resp *http.Response) (result HeaderClientResponseStringResponse, err error) {
	if val := resp.Header.Get("value"); val != "" {
		result.Value = &val
	}
	return result, nil
}
