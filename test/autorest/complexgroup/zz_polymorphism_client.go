//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package complexgroup

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/tracing"
	"net/http"
)

// PolymorphismClient contains the methods for the Polymorphism group.
// Don't use this type directly, use a constructor function instead.
type PolymorphismClient struct {
	internal *azcore.Client
}

// GetComplicated - Get complex types that are polymorphic, but not at the root of the hierarchy; also have additional properties
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientGetComplicatedOptions contains the optional parameters for the PolymorphismClient.GetComplicated
//     method.
func (client *PolymorphismClient) GetComplicated(ctx context.Context, options *PolymorphismClientGetComplicatedOptions) (result PolymorphismClientGetComplicatedResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.GetComplicated", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getComplicatedCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getComplicatedHandleResponse(resp)
	return
}

// getComplicatedCreateRequest creates the GetComplicated request.
func (client *PolymorphismClient) getComplicatedCreateRequest(ctx context.Context, options *PolymorphismClientGetComplicatedOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/complicated"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComplicatedHandleResponse handles the GetComplicated response.
func (client *PolymorphismClient) getComplicatedHandleResponse(resp *http.Response) (result PolymorphismClientGetComplicatedResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result); err != nil {
		result = PolymorphismClientGetComplicatedResponse{}
		return
	}
	return result, nil
}

// GetComposedWithDiscriminator - Get complex object composing a polymorphic scalar property and array property with polymorphic
// element type, with discriminator specified. Deserialization must NOT fail and use the discriminator type
// specified on the wire.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientGetComposedWithDiscriminatorOptions contains the optional parameters for the PolymorphismClient.GetComposedWithDiscriminator
//     method.
func (client *PolymorphismClient) GetComposedWithDiscriminator(ctx context.Context, options *PolymorphismClientGetComposedWithDiscriminatorOptions) (result PolymorphismClientGetComposedWithDiscriminatorResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.GetComposedWithDiscriminator", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getComposedWithDiscriminatorCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getComposedWithDiscriminatorHandleResponse(resp)
	return
}

// getComposedWithDiscriminatorCreateRequest creates the GetComposedWithDiscriminator request.
func (client *PolymorphismClient) getComposedWithDiscriminatorCreateRequest(ctx context.Context, options *PolymorphismClientGetComposedWithDiscriminatorOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/composedWithDiscriminator"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComposedWithDiscriminatorHandleResponse handles the GetComposedWithDiscriminator response.
func (client *PolymorphismClient) getComposedWithDiscriminatorHandleResponse(resp *http.Response) (result PolymorphismClientGetComposedWithDiscriminatorResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DotFishMarket); err != nil {
		result = PolymorphismClientGetComposedWithDiscriminatorResponse{}
		return
	}
	return result, nil
}

// GetComposedWithoutDiscriminator - Get complex object composing a polymorphic scalar property and array property with polymorphic
// element type, without discriminator specified on wire. Deserialization must NOT fail and use the explicit
// type of the property.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientGetComposedWithoutDiscriminatorOptions contains the optional parameters for the PolymorphismClient.GetComposedWithoutDiscriminator
//     method.
func (client *PolymorphismClient) GetComposedWithoutDiscriminator(ctx context.Context, options *PolymorphismClientGetComposedWithoutDiscriminatorOptions) (result PolymorphismClientGetComposedWithoutDiscriminatorResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.GetComposedWithoutDiscriminator", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getComposedWithoutDiscriminatorCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getComposedWithoutDiscriminatorHandleResponse(resp)
	return
}

// getComposedWithoutDiscriminatorCreateRequest creates the GetComposedWithoutDiscriminator request.
func (client *PolymorphismClient) getComposedWithoutDiscriminatorCreateRequest(ctx context.Context, options *PolymorphismClientGetComposedWithoutDiscriminatorOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/composedWithoutDiscriminator"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getComposedWithoutDiscriminatorHandleResponse handles the GetComposedWithoutDiscriminator response.
func (client *PolymorphismClient) getComposedWithoutDiscriminatorHandleResponse(resp *http.Response) (result PolymorphismClientGetComposedWithoutDiscriminatorResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result.DotFishMarket); err != nil {
		result = PolymorphismClientGetComposedWithoutDiscriminatorResponse{}
		return
	}
	return result, nil
}

// GetDotSyntax - Get complex types that are polymorphic, JSON key contains a dot
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientGetDotSyntaxOptions contains the optional parameters for the PolymorphismClient.GetDotSyntax
//     method.
func (client *PolymorphismClient) GetDotSyntax(ctx context.Context, options *PolymorphismClientGetDotSyntaxOptions) (result PolymorphismClientGetDotSyntaxResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.GetDotSyntax", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getDotSyntaxCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getDotSyntaxHandleResponse(resp)
	return
}

// getDotSyntaxCreateRequest creates the GetDotSyntax request.
func (client *PolymorphismClient) getDotSyntaxCreateRequest(ctx context.Context, options *PolymorphismClientGetDotSyntaxOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/dotsyntax"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDotSyntaxHandleResponse handles the GetDotSyntax response.
func (client *PolymorphismClient) getDotSyntaxHandleResponse(resp *http.Response) (result PolymorphismClientGetDotSyntaxResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result); err != nil {
		result = PolymorphismClientGetDotSyntaxResponse{}
		return
	}
	return result, nil
}

// GetValid - Get complex types that are polymorphic
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientGetValidOptions contains the optional parameters for the PolymorphismClient.GetValid method.
func (client *PolymorphismClient) GetValid(ctx context.Context, options *PolymorphismClientGetValidOptions) (result PolymorphismClientGetValidResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.GetValid", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.getValidCreateRequest(ctx, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.getValidHandleResponse(resp)
	return
}

// getValidCreateRequest creates the GetValid request.
func (client *PolymorphismClient) getValidCreateRequest(ctx context.Context, options *PolymorphismClientGetValidOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/valid"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getValidHandleResponse handles the GetValid response.
func (client *PolymorphismClient) getValidHandleResponse(resp *http.Response) (result PolymorphismClientGetValidResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result); err != nil {
		result = PolymorphismClientGetValidResponse{}
		return
	}
	return result, nil
}

// PutComplicated - Put complex types that are polymorphic, but not at the root of the hierarchy; also have additional properties
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientPutComplicatedOptions contains the optional parameters for the PolymorphismClient.PutComplicated
//     method.
func (client *PolymorphismClient) PutComplicated(ctx context.Context, complexBody SalmonClassification, options *PolymorphismClientPutComplicatedOptions) (result PolymorphismClientPutComplicatedResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.PutComplicated", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putComplicatedCreateRequest(ctx, complexBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putComplicatedCreateRequest creates the PutComplicated request.
func (client *PolymorphismClient) putComplicatedCreateRequest(ctx context.Context, complexBody SalmonClassification, options *PolymorphismClientPutComplicatedOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/complicated"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// PutMissingDiscriminator - Put complex types that are polymorphic, omitting the discriminator
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - options - PolymorphismClientPutMissingDiscriminatorOptions contains the optional parameters for the PolymorphismClient.PutMissingDiscriminator
//     method.
func (client *PolymorphismClient) PutMissingDiscriminator(ctx context.Context, complexBody SalmonClassification, options *PolymorphismClientPutMissingDiscriminatorOptions) (result PolymorphismClientPutMissingDiscriminatorResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.PutMissingDiscriminator", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putMissingDiscriminatorCreateRequest(ctx, complexBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	result, err = client.putMissingDiscriminatorHandleResponse(resp)
	return
}

// putMissingDiscriminatorCreateRequest creates the PutMissingDiscriminator request.
func (client *PolymorphismClient) putMissingDiscriminatorCreateRequest(ctx context.Context, complexBody SalmonClassification, options *PolymorphismClientPutMissingDiscriminatorOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/missingdiscriminator"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// putMissingDiscriminatorHandleResponse handles the PutMissingDiscriminator response.
func (client *PolymorphismClient) putMissingDiscriminatorHandleResponse(resp *http.Response) (result PolymorphismClientPutMissingDiscriminatorResponse, err error) {
	if err = runtime.UnmarshalAsJSON(resp, &result); err != nil {
		result = PolymorphismClientPutMissingDiscriminatorResponse{}
		return
	}
	return result, nil
}

// PutValid - Put complex types that are polymorphic
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - complexBody - Please put a salmon that looks like this: { 'fishtype':'Salmon', 'location':'alaska', 'iswild':true, 'species':'king',
//     'length':1.0, 'siblings':[ { 'fishtype':'Shark', 'age':6, 'birthday':
//     '2012-01-05T01:00:00Z', 'length':20.0, 'species':'predator', }, { 'fishtype':'Sawshark', 'age':105, 'birthday': '1900-01-05T01:00:00Z',
//     'length':10.0, 'picture': new Buffer([255, 255, 255, 255,
//     254]).toString('base64'), 'species':'dangerous', }, { 'fishtype': 'goblin', 'age': 1, 'birthday': '2015-08-08T00:00:00Z',
//     'length': 30.0, 'species': 'scary', 'jawsize': 5 } ] };
//   - options - PolymorphismClientPutValidOptions contains the optional parameters for the PolymorphismClient.PutValid method.
func (client *PolymorphismClient) PutValid(ctx context.Context, complexBody FishClassification, options *PolymorphismClientPutValidOptions) (result PolymorphismClientPutValidResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.PutValid", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putValidCreateRequest(ctx, complexBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putValidCreateRequest creates the PutValid request.
func (client *PolymorphismClient) putValidCreateRequest(ctx context.Context, complexBody FishClassification, options *PolymorphismClientPutValidOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/valid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, complexBody)
}

// PutValidMissingRequired - Put complex types that are polymorphic, attempting to omit required 'birthday' field - the request
// should not be allowed from the client
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2016-02-29
//   - complexBody - Please attempt put a sawshark that looks like this, the client should not allow this data to be sent: { "fishtype":
//     "sawshark", "species": "snaggle toothed", "length": 18.5, "age": 2, "birthday":
//     "2013-06-01T01:00:00Z", "location": "alaska", "picture": base64(FF FF FF FF FE), "siblings": [ { "fishtype": "shark", "species":
//     "predator", "birthday": "2012-01-05T01:00:00Z", "length": 20, "age": 6
//     }, { "fishtype": "sawshark", "species": "dangerous", "picture": base64(FF FF FF FF FE), "length": 10, "age": 105 } ] }
//   - options - PolymorphismClientPutValidMissingRequiredOptions contains the optional parameters for the PolymorphismClient.PutValidMissingRequired
//     method.
func (client *PolymorphismClient) PutValidMissingRequired(ctx context.Context, complexBody FishClassification, options *PolymorphismClientPutValidMissingRequiredOptions) (result PolymorphismClientPutValidMissingRequiredResponse, err error) {
	ctx, span := client.internal.Tracer().Start(ctx, "PolymorphismClient.PutValidMissingRequired", &tracing.SpanOptions{
		Kind: tracing.SpanKindInternal,
	})
	defer func() {
		if err != nil {
			span.AddError(err)
		}
		span.End()
	}()
	req, err := client.putValidMissingRequiredCreateRequest(ctx, complexBody, options)
	if err != nil {
		return
	}
	resp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		err = runtime.NewResponseError(resp)
		return
	}
	return
}

// putValidMissingRequiredCreateRequest creates the PutValidMissingRequired request.
func (client *PolymorphismClient) putValidMissingRequiredCreateRequest(ctx context.Context, complexBody FishClassification, options *PolymorphismClientPutValidMissingRequiredOptions) (*policy.Request, error) {
	urlPath := "/complex/polymorphism/missingrequired/invalid"
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, complexBody)
}
