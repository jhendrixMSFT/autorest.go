/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

import { adaptClients } from './clients.js';
import { adaptConstantType, adaptModel, adaptModelField } from './types.js';
import { GoEmitterOptions } from '../lib.js';
import * as go from '../../../codemodel.go/gocodemodel.js';
import { values } from '@azure-tools/linq';
import * as tcgc from '@azure-tools/typespec-client-generator-core';
import { EmitContext } from '@typespec/compiler';

const headerText = `Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License. See License.txt in the project root for license information.
Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.`;

export function tcgcToGoCodeModel(context: EmitContext<GoEmitterOptions>): go.CodeModel {
  const info = new go.Info('TODO Title');
  const options = new go.Options(headerText, context.options['generate-fakes'] === true, context.options['inject-spans'] === true, context.options['disallow-unknown-fields'] === true);
  if (context.options['azcore-version']) {
    options.azcoreVersion = context.options['azcore-version'];
  }

  const codeModel = new go.CodeModel(info, 'data-plane', packageNameFromOutputFolder(context.emitterOutputDir), options);
  if (context.options.module) {
    codeModel.options.module = context.options.module;
  }
  if (context.options['module-version']) {
    codeModel.options.moduleVersion = context.options['module-version'];
  }

  const sdkContext = tcgc.createSdkContext(context);
  const modelObjs = new Array<ModelTypeSdkModelType>();

  for (const enumType of sdkContext.sdkPackage.enums) {
    const constType = adaptConstantType(enumType);
    codeModel.constants.push(constType);
  }

  // we must adapt all model types first. this is because models can contain cyclic references
  for (const modelType of sdkContext.sdkPackage.models) {
    // TODO: what's the equivalent of x-ms-external?
    const model = adaptModel(modelType);
    modelObjs.push({type: model, obj: modelType});
  }

  // now adapt model fields
  for (const modelObj of modelObjs) {
    modelObj.type.fields = new Array<go.ModelField>();
    const props = aggregateProperties(modelObj.obj);
    for (const prop of values(props)) {
      if (prop.kind !== 'property') {
        throw new Error(`unexpected kind ${prop.kind} for property ${prop.nameInClient} in model ${modelObj.obj.name}`);
      }
      const field = adaptModelField(prop, modelObj.obj);
      modelObj.type.fields.push(field);
    }
    codeModel.models.push(modelObj.type);
  }

  adaptClients(sdkContext.sdkPackage, codeModel);
  sortContent(codeModel);
  return codeModel;
}

interface ModelTypeSdkModelType {
  type: go.ModelType | go.PolymorphicType;
  obj: tcgc.SdkModelType;
}

// returns the leaf folder name from the provided folder
function packageNameFromOutputFolder(folder: string): string {
  for (let i = folder.length - 1; i > -1; --i) {
    if (folder[i] === '/' || folder[i] === '\\') {
      return folder.substring(i + 1);
    }
  }
  // no path separator
  return folder;
}

// aggregate the properties from the provided type and its parent types
function aggregateProperties(model: tcgc.SdkModelType): Array<tcgc.SdkModelPropertyType> {
  const allProps = new Array<tcgc.SdkModelPropertyType>();
  for (const prop of model.properties) {
    allProps.push(prop);
  }
  let parent = model.baseModel;
  while (parent) {
    for (const parentProp of parent.properties) {
      // ensure that the parent doesn't contain any properties with the same name but different type
      const exists = values(allProps).where(p => { return p.nameInClient === parentProp.nameInClient; }).first();
      if (exists) {
        if (exists.type !== parentProp.type) {
          const msg = `type ${model.name} contains duplicate property ${exists.nameInClient} with mismatched types`;
          throw new Error(msg);
        }
        // don't add the duplicate
        continue;
      }
      allProps.push(parentProp);
    }
    parent = parent.baseModel;
  }
  return allProps;
}

function sortContent(codeModel: go.CodeModel) {
  codeModel.constants.sort((a: go.ConstantType, b: go.ConstantType) => { return sortAscending(a.name, b.name); });
  for (const enm of values(codeModel.constants)) {
    enm.values.sort((a: go.ConstantValue, b: go.ConstantValue) => { return sortAscending(a.valueName, b.valueName); });
  }

  codeModel.interfaceTypes.sort((a: go.InterfaceType, b: go.InterfaceType) => { return sortAscending(a.name, b.name); });
  for (const iface of values(codeModel.interfaceTypes)) {
    iface.possibleTypes.sort((a: go.PolymorphicType, b: go.PolymorphicType) => { return sortAscending(a.discriminatorValue!, b.discriminatorValue!); });
  }

  codeModel.models.sort((a: go.ModelType | go.PolymorphicType, b: go.ModelType | go.PolymorphicType) => { return sortAscending(a.name, b.name); });
  for (const model of values(codeModel.models)) {
    model.fields.sort((a: go.ModelField, b: go.ModelField) => { return sortAscending(a.fieldName, b.fieldName); });
  }

  codeModel.paramGroups.sort((a: go.StructType, b: go.StructType) => { return sortAscending(a.name, b.name); });
  for (const paramGroup of values(codeModel.paramGroups)) {
    paramGroup.fields.sort((a: go.StructField, b: go.StructField) => { return sortAscending(a.fieldName, b.fieldName); });
  }

  codeModel.responseEnvelopes.sort((a: go.ResponseEnvelope, b: go.ResponseEnvelope) => { return sortAscending(a.name, b.name); });
  for (const respEnv of values(codeModel.responseEnvelopes)) {
    respEnv.headers.sort((a: go.HeaderResponse | go.HeaderMapResponse, b: go.HeaderResponse | go.HeaderMapResponse) => { return sortAscending(a.fieldName, b.fieldName); });
  }

  codeModel.clients.sort((a: go.Client, b: go.Client) => { return sortAscending(a.clientName, b.clientName); });
  for (const client of values(codeModel.clients)) {
    client.methods.sort((a: go.Method, b: go.Method) => { return sortAscending(a.methodName, b.methodName); });
  }
}

function sortAscending(a: string, b: string): number {
  return a < b ? -1 : a > b ? 1 : 0;
}
